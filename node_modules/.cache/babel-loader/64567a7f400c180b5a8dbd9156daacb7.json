{"ast":null,"code":"import { takeEvery, call, put, select, flush, delay } from \"redux-saga/effects\";\nimport axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\nimport { conforms } from \"lodash\";\nconst coinListDataUtils = {\n  marketNames: names => {\n    const data = {};\n    names.forEach(name => {\n      let shortSym = name.market.split(\"-\")[1];\n      let moneySym = name.market.split(\"-\")[0];\n\n      if (moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitSym: name.market\n        };\n      } else if (moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDT: name.market\n        };\n      } else if (moneySym === \"BTC\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitBTC: name.market\n        };\n      }\n    });\n    return data;\n  },\n  upbitAllNames: names => {\n    const data = {}; //console.log(names);\n\n    names.forEach(name => {\n      data[name.market] = {\n        korean: name.korean_name,\n        english: name.english_name\n      };\n    });\n    return data;\n  },\n  upbitPriceNames: (names, state) => {\n    const coinStateDatas = state.Coin.upbitTotalNames.data;\n    names.forEach(name => {\n      //console.log(\"name\", name);\n      let nowPrice = parseFloat(name.trade_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      coinStateDatas[name.market] = {\n        korean: nowPrice\n      };\n    });\n    return coinStateDatas;\n  },\n  binanceNames: names => {\n    const data = {};\n    names.forEach(name => {\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      }\n    }); //console.log(data);\n\n    return data;\n  },\n  bithumbKRWNames: names => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      let nowPrice = parseFloat(names[name].closing_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      data[name + \"_KRW\"] = {\n        korean: nowPrice\n      };\n    });\n    return data;\n  },\n  bithumbBTCNames: (names, state) => {\n    const coinStateDatas = state.Coin.bithumbTotalNames.data;\n    Object.keys(names).forEach(name => {\n      let nowPrice = parseFloat(names[name].closing_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      coinStateDatas[name + \"_BTC\"] = {\n        korean: nowPrice\n      };\n    });\n    return coinStateDatas;\n  }\n};\nconst coinReadDataUtils = {\n  upbitUpdates: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data; //console.log(\"name\", names);\n\n    names.forEach(name => {\n      let shortSym = name.code.split(\"-\")[1];\n      let moneySym = name.code.split(\"-\")[0];\n      let nowPrice = parseFloat(name.trade_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitPrice: nowPrice\n        }; //return coinStateDatas;\n      } else if (moneySym === \"USDT\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitUSDTPrice: nowPrice\n        }; //return coinStateDatas;\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitBTCPrice: nowPrice\n        };\n      }\n    });\n    return coinStateDatas;\n  },\n  getUpbitAllMarketNameSagabithumbUpdates: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    names.forEach(name => {\n      let shortSym = name.symbol.split(\"_\")[0];\n      let moneySym = name.symbol.split(\"_\")[1];\n      let nowPrice = name.closePrice;\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: nowPrice\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: nowPrice\n        };\n      }\n    });\n    return coinStateDatas;\n  },\n  //✅\n  mixExchangeUpdates: (one_names, two_names, three_names, gecko_data, state) => {\n    const coinStateDatas = state.Coin.marketNames.data; //✅ gecko\n\n    /* Object.keys(gecko_data).map(name => {\n         let shortSym = CoinMarketData.find((coinsym) => {\n             if (coinsym.totalName === name)\n                 return coinsym;\n         })\n           coinStateDatas[shortSym.symbol] = {\n             ...coinStateDatas[shortSym.symbol],\n             gecko: gecko_data[name].usd\n         }\n     });*/\n    //✅ bithumb\n\n    two_names.forEach(name => {\n      let shortSym = name.symbol.split(\"_\")[0];\n      let moneySym = name.symbol.split(\"_\")[1];\n      let nowPrice = name.closePrice;\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: nowPrice\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: nowPrice\n        };\n      }\n    }); //✅ upbit\n\n    one_names.forEach(name => {\n      let shortSym = name.code.split(\"-\")[1];\n      let moneySym = name.code.split(\"-\")[0];\n      let nowPrice = name.trade_price;\n      var sortOrder = [];\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitPrice: nowPrice\n        };\n      } else if (moneySym === \"USDT\") {\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1); //!\n\n        if (coinStateDatas[shortSym]) {\n          Object.keys(coinStateDatas[shortSym]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n          /*\n          if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }*/\n        }\n\n        if (shortSym === 'DGB') console.log(shortSym, sortOrder[0], sortOrder[1], sortOrder[2]);\n\n        if (sortOrder[0] === 'upbitSym') {\n          var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        } else if (sortOrder[1] === 'upbitBTC') {\n          var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2); //var calper = 'None';\n        } else {\n          var calper = \"None\";\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitUSDTPrice: nowPrice,\n          upbitUSDT_start_per: calper,\n          calKoupbitUSDT: cal\n        };\n      } else if (moneySym === \"BTC\") {\n        var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n        var cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n        if (shortSym === 'COMP') {\n          console.log('comp', origin, cal, coinStateDatas['BTC']);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitBTCPrice: nowPrice,\n          calKoupbitBTC: cal\n        };\n      }\n\n      if (coinStateDatas['BTC'].upbitPrice) {\n        var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n        coinStateDatas['USDT'] = { ...coinStateDatas['USDT'],\n          upbitUSDT: 'USDTKRW',\n          upbitUSDTPrice: upbitusdtkrw\n        };\n      }\n    }); //✅ binance\n\n    three_names.forEach(name => {\n      let nowPrice = name.price;\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      var sortOrder = [];\n\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        var len = name.symbol.indexOf('BTC');\n        var coin = name.symbol.slice(0, len);\n        var cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1);\n\n        if (coinStateDatas[coin]) {\n          Object.keys(coinStateDatas[coin]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        var calper;\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === \"upbitUSDT\") {\n          calper = \"prepare\";\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBTCSym: name.symbol,\n            binanBTCPrice: nowPrice,\n            calKobinanBTC: cal,\n            binBTC_start_per: calper\n          };\n        }\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        var len = name.symbol.indexOf('USDT');\n        var coin = name.symbol.slice(0, len);\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        var calper;\n\n        if (coinStateDatas[coin]) {\n          Object.keys(coinStateDatas[coin]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = \"prepare\";\n        } else if (sortOrder[0] === \"upbitUSDT\") {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanUSDTSym: name.symbol,\n            binanUSDTPrice: nowPrice,\n            calKoUSDT: cal,\n            //(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n            binUSDT_start_per: calper\n          };\n        }\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        var len = name.symbol.indexOf('BUSD');\n        var coin = name.symbol.slice(0, len);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBNBSym: name.symbol,\n            binanBNBPrice: nowPrice //calKoUSDT: (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n          };\n        }\n      }\n\n      if (name.symbol === 'BTCBUSD') {\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanBNBSym: name.symbol,\n          binanBNBPrice: nowPrice\n        };\n      } else if (name.symbol === 'BTCUSDT') {\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanUSDTSym: name.symbol,\n          binanUSDTPrice: nowPrice,\n          calKoUSDT: cal,\n          per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n        };\n      }\n    });\n    return coinStateDatas;\n  },\n  //\n  upbitInitNames: (names, state) => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n\n      if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name\n        };\n      } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n        data['USDT'] = { ...data['USDT'],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name\n        };\n      }\n    });\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n      let imgsrc = \"\";\n      CoinMarketData.find(coin => {\n        if (coin.symbol === shortSym) {\n          imgsrc = coin.imgsrc;\n        }\n      });\n\n      if (moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name,\n          imgsrc: imgsrc\n        };\n      } else if (moneySym === \"USDT\") {\n        var cal = (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1);\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name,\n          imgsrc: imgsrc,\n          calKoUSDT: cal\n        };\n      } else if (moneySym === \"BTC\") {\n        var cal = (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2);\n        data[shortSym] = { ...data[shortSym],\n          upbitBTCPrice: names[name].korean,\n          upbitBTC: name,\n          imgsrc: imgsrc,\n          calKoupbitBTC: cal\n        };\n      }\n    });\n    return data;\n  },\n  bithumbInitNames: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"_\")[0];\n      let moneySym = name.split(\"_\")[1];\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: names[name].korean,\n          bithumbSym: name\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: names[name].korean,\n          bithumbBTC: name\n        };\n      }\n    });\n    return coinStateDatas;\n  }\n};\nexport { coinListDataUtils, coinReadDataUtils };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/utils.js"],"names":["takeEvery","call","put","select","flush","delay","axios","CoinMarketData","conforms","coinListDataUtils","marketNames","names","data","forEach","name","shortSym","market","split","moneySym","upbitSym","upbitUSDT","upbitBTC","upbitAllNames","korean","korean_name","english","english_name","upbitPriceNames","state","coinStateDatas","Coin","upbitTotalNames","nowPrice","parseFloat","trade_price","toFixed","binanceNames","symbol","lastIndexOf","price","bithumbKRWNames","Object","keys","closing_price","bithumbBTCNames","bithumbTotalNames","coinReadDataUtils","upbitUpdates","code","upbitPrice","upbitUSDTPrice","upbitBTCPrice","getUpbitAllMarketNameSagabithumbUpdates","closePrice","bithumbPrice","bithumbBTCPrice","mixExchangeUpdates","one_names","two_names","three_names","gecko_data","sortOrder","cal","filter","list","console","log","calper","calKoupbitBTC","upbitUSDT_start_per","calKoupbitUSDT","origin","upbitusdtkrw","len","indexOf","coin","slice","splice","binanBTCSym","binanBTCPrice","calKobinanBTC","binBTC_start_per","binanUSDTSym","binanUSDTPrice","calKoUSDT","binUSDT_start_per","binanBNBSym","binanBNBPrice","per","upbitInitNames","imgsrc","find","bithumbInitNames","bithumbSym","bithumbBTC"],"mappings":"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","sourcesContent":["import { takeEvery, call, put, select, flush, delay } from \"redux-saga/effects\";\nimport axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\nimport { conforms } from \"lodash\";\n\nconst coinListDataUtils = {\n    marketNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            let shortSym = name.market.split(\"-\")[1];\n            let moneySym = name.market.split(\"-\")[0];\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitSym: name.market\n                }\n            } else if (moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDT: name.market\n                }\n            } else if (moneySym === \"BTC\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTC: name.market\n                }\n            }\n        });\n        return data;\n    },\n    upbitAllNames: (names) => {\n        const data = {};\n        //console.log(names);\n        names.forEach(name => {\n            data[name.market] = {\n                korean: name.korean_name,\n                english: name.english_name,\n            };\n        })\n        return data;\n    },\n    upbitPriceNames: (names, state) => {\n        const coinStateDatas = state.Coin.upbitTotalNames.data;\n\n        names.forEach(name => {\n            //console.log(\"name\", name);\n            let nowPrice = parseFloat(name.trade_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            coinStateDatas[name.market] = {\n                korean: nowPrice,\n            };\n        })\n        return coinStateDatas;\n    },\n\n    binanceNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            }\n\n        })\n        //console.log(data);\n        return data;\n    },\n    bithumbKRWNames: (names) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let nowPrice = parseFloat(names[name].closing_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            data[name + \"_KRW\"] = {\n                korean: nowPrice,\n            };\n        })\n\n        return data;\n    },\n    bithumbBTCNames: (names, state) => {\n        const coinStateDatas = state.Coin.bithumbTotalNames.data;\n\n        Object.keys(names).forEach(name => {\n            let nowPrice = parseFloat(names[name].closing_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            coinStateDatas[name + \"_BTC\"] = {\n                korean: nowPrice,\n            };\n        })\n        return coinStateDatas;\n    }\n};\n\nconst coinReadDataUtils = {\n    upbitUpdates: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //console.log(\"name\", names);\n        names.forEach(name => {\n\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = parseFloat(name.trade_price);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n                //return coinStateDatas;\n            } else if (moneySym === \"USDT\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice\n                }\n                //return coinStateDatas;\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice\n                }\n            }\n        });\n        return coinStateDatas;\n    },\n    getUpbitAllMarketNameSagabithumbUpdates: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        names.forEach(name => {\n\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = name.closePrice;\n\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            } else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice\n                }\n            }\n        });\n        return coinStateDatas;\n    },\n    //✅\n    mixExchangeUpdates: (one_names, two_names, three_names, gecko_data, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //✅ gecko\n        /* Object.keys(gecko_data).map(name => {\n             let shortSym = CoinMarketData.find((coinsym) => {\n                 if (coinsym.totalName === name)\n                     return coinsym;\n             })\n \n             coinStateDatas[shortSym.symbol] = {\n                 ...coinStateDatas[shortSym.symbol],\n                 gecko: gecko_data[name].usd\n             }\n         });*/\n\n        //✅ bithumb\n        two_names.forEach(name => {\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = name.closePrice;\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice\n                }\n            }\n        });\n        //✅ upbit\n        one_names.forEach(name => {\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = name.trade_price;\n            var sortOrder = [];\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n            } else if (moneySym === \"USDT\") {\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                //!\n                if (coinStateDatas[shortSym]) {\n                    Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })/*\n                    if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }*/\n                }\n\n                if (shortSym === 'DGB')\n                    console.log(shortSym, sortOrder[0], sortOrder[1], sortOrder[2]);\n                if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2)\n                } else if (sortOrder[1] === 'upbitBTC') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                    //var calper = 'None';\n                } else {\n                    var calper = \"None\";\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice,\n\n                    upbitUSDT_start_per: calper,\n                    calKoupbitUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n                var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n                var cal = (origin * parseFloat(nowPrice)).toFixed(2)\n                if (shortSym === 'COMP') {\n                    console.log('comp', origin, cal, coinStateDatas['BTC']);\n                }\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice,\n\n                    calKoupbitBTC: cal\n                }\n            }\n\n            if (coinStateDatas['BTC'].upbitPrice) {\n                var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n\n                coinStateDatas['USDT'] = {\n                    ...coinStateDatas['USDT'],\n\n                    upbitUSDT: 'USDTKRW',\n                    upbitUSDTPrice: upbitusdtkrw\n                }\n            }\n        });\n\n\n        //✅ binance\n        three_names.forEach(name => {\n            let nowPrice = name.price;\n\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            var sortOrder = [];\n\n\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                var len = name.symbol.indexOf('BTC');\n                var coin = name.symbol.slice(0, len);\n                var cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                var calper;\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    calper = \"prepare\";\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBTCSym: name.symbol,\n                        binanBTCPrice: nowPrice,\n                        calKobinanBTC: cal,\n                        binBTC_start_per: calper\n                    }\n                }\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                var len = name.symbol.indexOf('USDT');\n\n                var coin = name.symbol.slice(0, len);\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n\n\n                var calper;\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = \"prepare\";\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanUSDTSym: name.symbol,\n                        binanUSDTPrice: nowPrice,\n                        calKoUSDT: cal,//(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                        binUSDT_start_per: calper,\n                    }\n                }\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                var len = name.symbol.indexOf('BUSD');\n                var coin = name.symbol.slice(0, len);\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBNBSym: name.symbol,\n                        binanBNBPrice: nowPrice,\n                        //calKoUSDT: (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                    }\n                }\n            }\n\n            if (name.symbol === 'BTCBUSD') {\n\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanBNBSym: name.symbol,\n                    binanBNBPrice: nowPrice\n\n                }\n            } else if (name.symbol === 'BTCUSDT') {\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanUSDTSym: name.symbol,\n                    binanUSDTPrice: nowPrice,\n                    calKoUSDT: cal,\n                    per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n                }\n            }\n        });\n\n        return coinStateDatas;\n    },\n    //\n    upbitInitNames: (names, state) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n\n            if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                }\n            } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n                data['USDT'] = {\n                    ...data['USDT'],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                }\n            }\n        })\n\n        Object.keys(names).forEach(name => {\n\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n            let imgsrc = \"\";\n            CoinMarketData.find((coin) => {\n                if (coin.symbol === shortSym) {\n                    imgsrc = coin.imgsrc;\n                }\n            })\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                    imgsrc: imgsrc\n                }\n            } else if (moneySym === \"USDT\") {\n\n                var cal = (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                    imgsrc: imgsrc,\n                    calKoUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n\n                var cal = (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTCPrice: names[name].korean,\n                    upbitBTC: name,\n                    imgsrc: imgsrc,\n                    calKoupbitBTC: cal\n                }\n            }\n        });\n        return data;\n    },\n    bithumbInitNames: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"_\")[0];\n            let moneySym = name.split(\"_\")[1];\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: names[name].korean,\n                    bithumbSym: name,\n                }\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: names[name].korean,\n                    bithumbBTC: name,\n                }\n            }\n        })\n\n\n        return coinStateDatas;\n    }\n};\n\n\nexport {\n    coinListDataUtils,\n    coinReadDataUtils\n}"]},"metadata":{},"sourceType":"module"}