{"ast":null,"code":"import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\nimport { bithumbcoinApi } from \"../Api/api\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    /*var res;\n    var ress;\n    if (type === \"GET_BITHUMB_MARKET_NAMES\") {\n        res = yield call(bithumbcoinApi.getKRWMarketCodes);\n        ress = yield call(bithumbcoinApi.getBTCMarketCodes);\n    }*/\n    //✅ 업비트\n    const res = yield call(api, action.payload);\n\n    try {\n      const state = yield select();\n      if (type === \"GET_UPBIT_MARKET_NAMES\") yield put({\n        type: SUCCESS,\n        payload: dataMaker(res.data, state)\n      });else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\") yield put({\n        type: SUCCESS,\n        payload: dataMaker(res.data.data, state)\n      });\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n      throw e;\n    }\n  };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    try {\n      //const state = yield select();\n      //const marketNames = Object.keys(state.Coin.upbitTotalNames.data);\n      console.log(\"12354\", action); //yield put({ type: SUCCESS, payload: dataMaker(marketNames, state) });\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n      throw e;\n    }\n  };\n}; // requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\n\n\nconst requestActions = (type, key) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return (state, action) => {\n    //console.log(state, action);\n    switch (action.type) {\n      case SUCCESS:\n        //console.log(15);\n        return reducerUtils.success(state, action.payload, key);\n\n      case ERROR:\n        return reducerUtils.error(state, action.payload, key);\n\n      default:\n        return state;\n    }\n  };\n};\n\nconst reducerUtils = {\n  success: (state, payload, key) => {\n    return { ...state,\n      [key]: {\n        data: payload,\n        error: false\n      }\n    };\n  },\n  error: (state, error, key) => ({ ...state,\n    [key]: { ...state[key],\n      error: error\n    }\n  })\n};\n\nconst createUpbitSocket = () => {\n  const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n  client.binaryType = \"arraybuffer\";\n  return client;\n};\n\nconst createBithumbSocket = () => {\n  const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n  client.binaryType = \"arraybuffer\";\n  return client;\n}; // 소켓 연결용\n\n\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n  //console.log(type);\n  return eventChannel(emit => {\n    socket.onopen = () => {\n      if (type === \"CONNECT_UPBIT_SOCKET\") {\n        socket.send(JSON.stringify([{\n          ticket: \"coinbread-clone\"\n        }, {\n          type: connectType,\n          codes: action.payload\n        }]));\n      } else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n        socket.send(JSON.stringify({\n          type: connectType,\n          symbols: [\"BTC_KRW\"],\n          tickTypes: [\"MID\"]\n        }));\n      }\n    };\n\n    socket.onmessage = evt => {\n      //upbit\n\n      /*const enc = new encoding.TextDecoder(\"utf-8\");\n      const data = JSON.parse(enc.decode(evt.data));\n      emit(data);*/\n      console.log(JSON.parse(evt.data));\n    };\n\n    socket.onerror = evt => {\n      emit(evt);\n      emit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.close();\n    };\n\n    return unsubscribe;\n  }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    var client;\n    var clientChannel;\n    if (type === \"CONNECT_UPBIT_SOCKET\") client = yield call(createUpbitSocket);else if (type === \"CONNECT_BITHUMB_SOCKET\") client = yield call(createBithumbSocket);\n    clientChannel = yield call(connectSocekt, client, connectType, type, action, buffers.expanding(500));\n\n    try {\n      while (true) {\n        const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n\n        const state = yield select();\n\n        if (datas.length) {\n          const sortedObj = {};\n          datas.forEach(data => {\n            if (sortedObj[data.code]) {\n              // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n              sortedObj[data.code] = sortedObj[data.code].timestamp > data.timestamp ? sortedObj[data.code] : data;\n            } else {\n              sortedObj[data.code] = data;\n            }\n\n            sortedObj[data.code] = data;\n          });\n          const sortedData = Object.keys(sortedObj).map(data => sortedObj[data]);\n          yield put({\n            type: SUCCESS,\n            payload: dataMaker(sortedData, state)\n          });\n        }\n\n        yield delay(500); // 500ms 동안 대기\n      }\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n    } finally {\n      clientChannel.close();\n    }\n  };\n};\n\nexport { createRequestSaga, requestActions, createConnectSocketSaga, createInitRequestSaga };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/asyncUtil.js"],"names":["call","put","select","flush","delay","w3cwebsocket","W3CWebSocket","buffers","eventChannel","END","encoding","bithumbcoinApi","createRequestSaga","type","api","dataMaker","SUCCESS","ERROR","action","res","payload","state","data","e","createInitRequestSaga","console","log","requestActions","key","reducerUtils","success","error","createUpbitSocket","client","binaryType","createBithumbSocket","connectSocekt","socket","connectType","buffer","emit","onopen","send","JSON","stringify","ticket","codes","symbols","tickTypes","onmessage","evt","parse","onerror","unsubscribe","close","none","createConnectSocketSaga","clientChannel","expanding","datas","length","sortedObj","forEach","code","timestamp","sortedData","Object","keys","map"],"mappings":"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","sourcesContent":["import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\nimport { bithumbcoinApi } from \"../Api/api\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        /*var res;\n        var ress;\n        if (type === \"GET_BITHUMB_MARKET_NAMES\") {\n            res = yield call(bithumbcoinApi.getKRWMarketCodes);\n            ress = yield call(bithumbcoinApi.getBTCMarketCodes);\n        }*/\n\n        //✅ 업비트\n        const res = yield call(api, action.payload);\n\n\n\n        try {\n            const state = yield select();\n            if (type === \"GET_UPBIT_MARKET_NAMES\")\n                yield put({ type: SUCCESS, payload: dataMaker(res.data, state) });\n            else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\")\n                yield put({ type: SUCCESS, payload: dataMaker(res.data.data, state) });\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        try {\n            //const state = yield select();\n            //const marketNames = Object.keys(state.Coin.upbitTotalNames.data);\n            console.log(\"12354\", action);\n            //yield put({ type: SUCCESS, payload: dataMaker(marketNames, state) });\n\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\n// requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\nconst requestActions = (type, key) => {\n    const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n\n    return (state, action) => {\n        //console.log(state, action);\n        switch (action.type) {\n            case SUCCESS:\n                //console.log(15);\n                return reducerUtils.success(state, action.payload, key);\n            case ERROR:\n                return reducerUtils.error(state, action.payload, key);\n            default:\n                return state;\n        }\n    };\n};\n\nconst reducerUtils = {\n    success: (state, payload, key) => {\n        return {\n            ...state,\n            [key]: {\n                data: payload,\n                error: false,\n            },\n        };\n    },\n    error: (state, error, key) => ({\n        ...state,\n        [key]: {\n            ...state[key],\n            error: error,\n        },\n    }),\n};\n\nconst createUpbitSocket = () => {\n    const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\nconst createBithumbSocket = () => {\n    const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\n\n\n// 소켓 연결용\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(type);\n    return eventChannel((emit) => {\n        socket.onopen = () => {\n            if (type === \"CONNECT_UPBIT_SOCKET\") {\n                socket.send(\n                    JSON.stringify([\n                        { ticket: \"coinbread-clone\" },\n                        { type: connectType, codes: action.payload },\n                    ])\n                );\n            } else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                socket.send(\n                    JSON.stringify(\n                        { type: connectType, symbols: [\"BTC_KRW\"], tickTypes: [\"MID\"] }\n                    )\n                );\n            }\n        };\n        socket.onmessage = (evt) => {\n            //upbit\n            /*const enc = new encoding.TextDecoder(\"utf-8\");\n            const data = JSON.parse(enc.decode(evt.data));\n            emit(data);*/\n\n            console.log(JSON.parse(evt.data));\n        };\n\n        socket.onerror = (evt) => {\n            emit(evt);\n            emit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        var client;\n        var clientChannel;\n        if (type === \"CONNECT_UPBIT_SOCKET\")\n            client = yield call(createUpbitSocket);\n        else if (type === \"CONNECT_BITHUMB_SOCKET\")\n            client = yield call(createBithumbSocket);\n\n        clientChannel = yield call(\n            connectSocekt,\n            client,\n            connectType,\n            type,\n            action,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const state = yield select();\n\n                if (datas.length) {\n                    const sortedObj = {};\n                    datas.forEach((data) => {\n                        if (sortedObj[data.code]) {\n                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                            sortedObj[data.code] =\n                                sortedObj[data.code].timestamp > data.timestamp\n                                    ? sortedObj[data.code]\n                                    : data;\n                        } else {\n                            sortedObj[data.code] = data;\n                        }\n                        sortedObj[data.code] = data;\n                    });\n\n                    const sortedData = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n                    yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n                }\n                yield delay(500); // 500ms 동안 대기\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }\n    };\n};\n\n\nexport {\n    createRequestSaga,\n    requestActions,\n    createConnectSocketSaga,\n    createInitRequestSaga,\n}"]},"metadata":{},"sourceType":"module"}