{"ast":null,"code":"import axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\n\nconst pricereturnFloat = price => {\n  let data = parseFloat(price);\n\n  if (data < 1.0) {\n    return data.toFixed(8);\n  } else {\n    return data.toFixed(1);\n  }\n};\n\nconst coinListDataUtils = {\n  kucoinAllNames: names => {\n    names.forEach(coinlist => {\n      var coinName = coinlist.symbol.split('-')[0];\n      var type = coinlist.symbol.split('-')[1];\n      var newCoin = false;\n\n      if (type !== 'ETH') {\n        CoinMarketData.find(name => {\n          if (name.symbol === coinName) {\n            newCoin = true;\n          }\n        });\n        /*if (newCoin === false) {\n            console.log(coinName, type);\n        }*/\n      }\n    });\n  },\n  upbitAllNames: names => {\n    const data = {};\n    names.forEach(name => {\n      data[name.market] = {\n        korean: name.korean_name\n      };\n    });\n    return data;\n  },\n  upbitPriceNames: (names, state) => {\n    const coinStateDatas = state.Coin.upbitTotalNames.data;\n    names.forEach(name => {\n      coinStateDatas[name.market] = {\n        korean: pricereturnFloat(name.trade_price)\n      };\n    });\n    return coinStateDatas;\n  },\n  binanceNames: names => {\n    const data = {};\n    names.forEach(name => {\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      }\n    });\n    return data;\n  },\n  bithumbKRWNames: names => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      data[name + \"_KRW\"] = {\n        korean: pricereturnFloat(names[name].closing_price)\n      };\n    });\n    return data;\n  },\n  bithumbBTCNames: (names, state) => {\n    const coinStateDatas = state.Coin.bithumbTotalNames.data;\n    Object.keys(names).forEach(name => {\n      coinStateDatas[name + \"_BTC\"] = {\n        korean: pricereturnFloat(names[name].closing_price)\n      };\n    });\n    return coinStateDatas;\n  }\n};\nconst coinReadDataUtils = {\n  mixExchangeUpdates: (one_names, two_names, three_names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    const TOPmarketNames = state.Coin.TOPmarketNames;\n    const TOPmarketString = state.Coin.TOPmarketString; //✅ bithumb\n\n    two_names.forEach(name => {\n      let shortSym = name.symbol.split(\"_\")[0];\n      let moneySym = name.symbol.split(\"_\")[1];\n      let nowPrice = pricereturnFloat(name.closePrice);\n      var sortOrder = [];\n      var cal, calper;\n\n      if (coinStateDatas[shortSym]) {\n        Object.keys(coinStateDatas[shortSym]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === \"KRW\") {\n        if (sortOrder[0] === 'upbitSym') {\n          calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: nowPrice,\n          bithumbKRW_start_per: calper\n        };\n      } else if (moneySym === \"BTC\") {\n        var origin = parseFloat(coinStateDatas['BTC'].bithumbPrice);\n        cal = (origin * parseFloat(nowPrice)).toFixed(2);\n        if (shortSym === 'MKR') console.log('MKR', coinStateDatas['BTC'].bithumbPrice, nowPrice, cal);\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: nowPrice,\n          calKobithumbBTC: cal\n        };\n      }\n    }); //✅ upbit\n\n    one_names.forEach(name => {\n      let shortSym = name.code.split(\"-\")[1];\n      let moneySym = name.code.split(\"-\")[0];\n      let nowPrice = pricereturnFloat(name.trade_price);\n      var sortOrder = [];\n      var cal, calper;\n\n      if (coinStateDatas[shortSym]) {\n        Object.keys(coinStateDatas[shortSym]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0] && !sortOrder[1]) {\n          sortOrder.splice(0, 2);\n        } else if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitPrice: nowPrice\n        };\n      } else if (moneySym === \"USDT\") {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n        if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitUSDT') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[1] === 'upbitBTC') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else {\n          calper = \"Prepare\";\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitUSDTPrice: nowPrice,\n          upbitUSDT_start_per: calper,\n          calKoupbitUSDT: cal\n        };\n      } else if (moneySym === \"BTC\") {\n        var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n        cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = 'prepare';\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitBTCPrice: nowPrice,\n          //!\n          calKoupbitBTC: cal,\n          upbitBTC_start_per: calper\n        };\n      }\n\n      if (coinStateDatas['BTC'].upbitPrice) {\n        //@\n        var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n        coinStateDatas['USDT'] = { ...coinStateDatas['USDT'],\n          upbitUSDT: 'USDTKRW',\n          upbitUSDTPrice: upbitusdtkrw\n        };\n      }\n    }); //✅ binance\n\n    three_names.forEach(name => {\n      let nowPrice = pricereturnFloat(name.price);\n      var sortOrder = [];\n      var len, cal, calper, coin;\n      let moneySym;\n      let exceptionArr = ['VENUSDT', 'VENBTC',, 'MBLBTC', 'TUSDBTC', 'DAIBTC', 'REPBUSD', 'STORJBUSD', 'DENTBTC', 'MFTBTC', 'SUNBTC', 'BTTBTC', 'COCOSBTC', 'PAXBTC', 'PAXUSDT', 'PAXBUSD', 'BCHSVBTC', 'BCHSVUSDT', 'BCCBTC', 'BCCUSDT', 'HOTBTC', 'BCHABCBTC', 'BCHABCUSDT', 'BCHABCBUSD', 'STORMBTC', 'STORMUSDT', 'LENDBTC', 'LENDUSDT', 'LENDBUSD', 'ERDBTC', 'ERDUSDT', 'ERDBUSD', 'MCOBTC', 'MCOUSDT', 'STRATBTC', 'STRATUSDT', 'STRATBUSD', 'VTHOBUSD', 'DCRBUSD', 'NPXSBTC', 'NPXSUSDT', 'BLZBUSD', 'WNXMBUSD', 'AIONBUSD', 'KMDBUSD', 'XZCBT', 'XZCUSDT', 'IRISBUSD', 'HCBTC', 'HCUSDT', 'KEYBTC', 'KEYUSDT', 'TROYBTC', 'SUSDBTC', 'TRUBUSD', 'BOOTBTC', 'BOTBUSD', 'PXGBUSD', 'BTSBUSD', 'RENBTCBTC', 'RENBTCETH'];\n      let exceptionflag = false;\n      exceptionArr.map(symbolName => {\n        if (name.symbol === symbolName) {\n          exceptionflag = true;\n          return;\n        }\n      });\n      if (exceptionflag === true) return coinStateDatas;\n\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        len = name.symbol.indexOf('BTC');\n        moneySym = 'BTC';\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        len = name.symbol.indexOf('USDT');\n        moneySym = 'USDT';\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        len = name.symbol.indexOf('BUSD');\n        moneySym = 'BUSD';\n      }\n\n      coin = name.symbol.slice(0, len);\n\n      if (coinStateDatas[coin]) {\n        Object.keys(coinStateDatas[coin]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0] && !sortOrder[1]) {\n          sortOrder.splice(0, 2);\n        } else if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === 'BTC') {\n        cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1);\n        if (sortOrder[0] === 'upbitBTC') calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === \"upbitUSDT\") calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === 'upbitSym') calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBTCSym: name.symbol,\n            binanBTCPrice: nowPrice,\n            calKobinanBTC: cal,\n            binBTC_start_per: calper\n          };\n        }\n      } else if (moneySym === 'USDT') {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        if (sortOrder[0] === 'upbitBTC') calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === \"upbitUSDT\") calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);else if (sortOrder[0] === 'upbitSym') calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanUSDTSym: name.symbol,\n            binanUSDTPrice: nowPrice,\n            calKoUSDT: cal,\n            binUSDT_start_per: calper\n          };\n        }\n      } else if (moneySym === 'BUSD') {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        if (sortOrder[0] === 'upbitBTC') calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === \"upbitUSDT\") calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);else if (sortOrder[0] === 'upbitSym') calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBNBSym: name.symbol,\n            binanBNBPrice: nowPrice,\n            calKoBUSD: cal,\n            binBUSD_start_per: calper\n          };\n        }\n      } //📌 EXCEPTION\n\n\n      if (name.symbol === 'BTCBUSD') {\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanBNBSym: name.symbol,\n          binanBNBPrice: nowPrice\n        };\n      } else if (name.symbol === 'BTCUSDT') {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanUSDTSym: name.symbol,\n          binanUSDTPrice: nowPrice,\n          calKoUSDT: cal,\n          per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n        };\n      }\n    }); //✅ Max per search\n\n    Object.keys(coinStateDatas).forEach(coin => {\n      var read = coinStateDatas[coin];\n      var keyread = Object.keys(read);\n      var maxPer = 0.0;\n      var minPer = 0.0;\n      keyread.forEach(name => {\n        var per;\n\n        if (name === 'bithumbKRW_start_per') {\n          per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n        } else if (name === 'binBUSD_start_per') {\n          per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n        } else if (name === 'upbitBTC_start_per') {\n          per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n        } else if (name === 'upbitUSDT_start_per') {\n          per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n        } else if (name === 'BTCper') {\n          per = parseFloat(coinStateDatas[coin].BTCper);\n        } else if (name === 'binUSDT_start_per') {\n          per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n        } else if (name === 'binBTC_start_per') {\n          per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n        }\n\n        if (per > maxPer) {\n          maxPer = per;\n        }\n\n        if (per < minPer) {\n          minPer = per;\n        }\n      });\n      coinStateDatas[coin] = { ...coinStateDatas[coin],\n        totalPer: maxPer,\n        totalminPer: minPer\n      };\n    }); //📦 v2\n\n    Object.keys(coinStateDatas).forEach(coin => {\n      var read = coinStateDatas[coin];\n      var keyread = Object.keys(read);\n      var maxPer = 0.0;\n      var minPer = Number.MAX_SAFE_INTEGER;\n      var sortExchange = [];\n      var exchange;\n      var lastminExchange, lastmaxExchange;\n      var minmaxExchange, maxExchange, minExchange;\n      keyread.forEach(name => {\n        var price;\n\n        if (name === 'upbitPrice') {\n          price = parseFloat(coinStateDatas[coin].upbitPrice);\n          sortExchange.push('upbit');\n          exchange = 'upbitWithdraw';\n          minmaxExchange = 'upbitKRW';\n        } else if (name === 'bithumbPrice') {\n          price = parseFloat(coinStateDatas[coin].bithumbPrice);\n          sortExchange.push('bithumb');\n          exchange = 'bithumbWithdraw';\n          minmaxExchange = 'bithumbKRW';\n        } else if (name === 'calKoupbitBTC') {\n          price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n          sortExchange.push('upbit');\n          exchange = 'upbitWithdraw';\n          minmaxExchange = 'upbitBTC';\n        } else if (name === 'calKobithumbBTC') {\n          price = parseFloat(coinStateDatas[coin].calKobithumbBTC); //ok\n\n          sortExchange.push('bithumb');\n          exchange = 'bithumbWithdraw';\n          minmaxExchange = 'bithumbBTC';\n        } else if (name === 'calKobinanBTC') {\n          price = parseFloat(coinStateDatas[coin].calKobinanBTC);\n          sortExchange.push('binance');\n          exchange = 'binanceWithdraw';\n          minmaxExchange = 'binanceBTC';\n        } else if (name === 'calKoupbitUSDT') {\n          price = parseFloat(coinStateDatas[coin].calKoupbitUSDT);\n          sortExchange.push('upbit');\n          minmaxExchange = 'upbitUSDT';\n        } else if (name === 'calKoUSDT') {\n          price = parseFloat(coinStateDatas[coin].calKoUSDT);\n          sortExchange.push('binance');\n          exchange = 'binanceWithdraw';\n          minmaxExchange = 'binanceUSDT';\n        } else if (name === 'calKoBUSD') {\n          price = parseFloat(coinStateDatas[coin].calKoBUSD);\n          sortExchange.push('binance');\n          exchange = 'binanceWithdraw';\n          minmaxExchange = 'binanceBUSD';\n        }\n\n        if (price > maxPer) {\n          maxPer = price;\n          maxExchange = minmaxExchange;\n          lastmaxExchange = exchange;\n        }\n\n        if (price < minPer) {\n          minPer = price;\n          minExchange = minmaxExchange;\n          lastminExchange = exchange;\n        }\n      });\n      sortExchange = Array.from(new Set(sortExchange));\n\n      if (coin === 'MKR') {\n        console.log('MKR price check', minPer, maxPer, coinStateDatas['MKR']);\n      }\n\n      var result = 0.0;\n\n      if (sortExchange.length <= 1) {\n        minPer = 0;\n        maxPer = 0;\n        result = 0;\n      } else {\n        CoinMarketData.find(name => {\n          if (name.symbol === coin) {\n            if (lastminExchange === 'bithumbWithdraw' && lastmaxExchange === 'bithumbWithdraw') {\n              minPer = 0;\n              maxPer = 0;\n              result = 0;\n              return;\n            } else if (lastminExchange === 'upbitWithdraw') {\n              if (name.upbitWithdraw !== 'NO') minPer = parseFloat(name.upbitWithdraw) * parseFloat(minPer) + minPer;else {\n                minPer = 0;\n                maxPer = 0;\n                result = 0;\n                return;\n              }\n            } else if (lastminExchange === 'bithumbWithdraw') {\n              minPer = parseFloat(name.bithumbWithdraw) * parseFloat(minPer) + minPer;\n            } else if (lastminExchange === 'binanceWithdraw') {\n              if (name.upbitWithdraw !== 'NO') minPer = parseFloat(name.binanceWithdraw) * parseFloat(minPer) + minPer;else {\n                minPer = 0;\n                maxPer = 0;\n                result = 0;\n                return;\n              }\n            }\n          }\n        });\n        if (!(minPer <= 0 || maxPer === 0)) result = ((maxPer - minPer) / minPer * 100).toFixed(1);else {\n          result = 0;\n        }\n      }\n\n      coinStateDatas[coin] = { ...coinStateDatas[coin],\n        testper: result,\n        symbol: coin,\n        minExchange: minExchange,\n        maxExchange: maxExchange\n      };\n    }); //!\n\n    TOPmarketNames.splice(0);\n    var coinStateCount = 0;\n    var coinStringMake = \"\";\n    Object.keys(coinStateDatas).forEach(coinOne => {\n      if (coinStateDatas[coinOne].testper > 0) {\n        coinStringMake += coinOne + \",\";\n        var dataFactory = [];\n        var keyread = Object.keys(coinStateDatas[coinOne]);\n        var arrCount = 0;\n        keyread.forEach(name => {\n          if (name === 'upbitPrice') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].upbitSym,\n              'exchange': 'upbit',\n              'OriginPrice': coinStateDatas[coinOne].upbitPrice,\n              'KrwPrice': coinStateDatas[coinOne].upbitPrice\n            };\n            arrCount++;\n          } else if (name === 'bithumbSym') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].bithumbSym,\n              'exchange': 'bithumb',\n              'OriginPrice': coinStateDatas[coinOne].bithumbPrice,\n              'KrwPrice': coinStateDatas[coinOne].bithumbPrice\n            };\n            arrCount++;\n          } else if (name === 'calKoupbitBTC') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].upbitBTC,\n              'exchange': 'upbit',\n              'OriginPrice': coinStateDatas[coinOne].upbitBTCPrice,\n              'KrwPrice': coinStateDatas[coinOne].calKoupbitBTC\n            };\n            arrCount++;\n          } else if (name === 'calKobithumbBTC') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].bithumbBTC,\n              'exchange': 'bithumb',\n              'OriginPrice': coinStateDatas[coinOne].bithumbBTCPrice,\n              'KrwPrice': coinStateDatas[coinOne].calKobithumbBTC\n            };\n            arrCount++;\n          } else if (name === 'calKoupbitUSDT') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].upbitUSDT,\n              'exchange': 'upbit',\n              'OriginPrice': coinStateDatas[coinOne].upbitUSDTPrice,\n              'KrwPrice': coinStateDatas[coinOne].calKoupbitUSDT\n            };\n            arrCount++;\n          } else if (name === 'calKobinanBTC') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].binanBTCSym,\n              'exchange': 'binance',\n              'OriginPrice': coinStateDatas[coinOne].binanBTCPrice,\n              'KrwPrice': coinStateDatas[coinOne].calKobinanBTC\n            };\n            arrCount++;\n          } else if (name === 'calKoUSDT') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].binanUSDTSym,\n              'exchange': 'binance',\n              'OriginPrice': coinStateDatas[coinOne].binanUSDTPrice,\n              'KrwPrice': coinStateDatas[coinOne].calKoUSDT\n            };\n            arrCount++;\n          } else if (name === 'calKoBUSD') {\n            dataFactory[arrCount] = {\n              'MainSym': coinOne,\n              'sym': coinStateDatas[coinOne].binanBNBSym,\n              'exchange': 'binance',\n              'OriginPrice': coinStateDatas[coinOne].binanBNBPrice,\n              'KrwPrice': coinStateDatas[coinOne].calKoBUSD\n            };\n            arrCount++;\n          }\n        }); //console.log('before', dataFactory); //1 2 3 4 5 \n\n        dataFactory = dataFactory.sort((next, prev) => {\n          if (parseFloat(next.KrwPrice) > parseFloat(prev.KrwPrice)) {\n            return -1;\n          } else {\n            return 0;\n          }\n        });\n        TOPmarketNames[coinStateCount] = dataFactory; //coinStateDatas[coinOne]\n\n        coinStateCount++;\n      }\n    });\n    TOPmarketString[0] = {\n      'ALL': coinStringMake\n    };\n    return coinStateDatas;\n  },\n  //\n  upbitInitNames: (names, state) => {\n    var stringdd = \"\";\n    CoinMarketData.find(name => {\n      stringdd += name.symbol + \" \";\n    });\n    const data = {};\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n\n      if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name\n        };\n      } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name\n        };\n      }\n    });\n    data['USDT'] = { ...data['USDT'],\n      upbitUSDTPrice: (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1),\n      upbitUSDT: 'USDTKRW'\n    };\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n      let imgsrc = \"\";\n      CoinMarketData.find(coin => {\n        if (coin.symbol === shortSym) {\n          imgsrc = coin.imgsrc;\n        }\n      });\n\n      if (moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name,\n          imgsrc: imgsrc\n        };\n      } else if (moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name,\n          imgsrc: imgsrc,\n          calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n        };\n      } else if (moneySym === \"BTC\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitBTCPrice: names[name].korean,\n          upbitBTC: name,\n          imgsrc: imgsrc,\n          calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n        };\n      }\n    });\n    return data;\n  },\n  bithumbInitNames: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"_\")[0];\n      let moneySym = name.split(\"_\")[1];\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: names[name].korean,\n          bithumbSym: name\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: names[name].korean,\n          bithumbBTC: name,\n          calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n        };\n      }\n    }); //!\n\n    return coinStateDatas;\n  }\n};\nexport { coinListDataUtils, coinReadDataUtils };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/utils.js"],"names":["axios","CoinMarketData","pricereturnFloat","price","data","parseFloat","toFixed","coinListDataUtils","kucoinAllNames","names","forEach","coinlist","coinName","symbol","split","type","newCoin","find","name","upbitAllNames","market","korean","korean_name","upbitPriceNames","state","coinStateDatas","Coin","upbitTotalNames","trade_price","binanceNames","lastIndexOf","bithumbKRWNames","Object","keys","closing_price","bithumbBTCNames","bithumbTotalNames","coinReadDataUtils","mixExchangeUpdates","one_names","two_names","three_names","marketNames","TOPmarketNames","TOPmarketString","shortSym","moneySym","nowPrice","closePrice","sortOrder","cal","calper","filter","list","splice","upbitPrice","bithumbPrice","bithumbKRW_start_per","origin","console","log","bithumbBTCPrice","calKobithumbBTC","code","upbitUSDTPrice","calKoupbitBTC","upbitUSDT_start_per","calKoupbitUSDT","upbitBTCPrice","upbitBTC_start_per","upbitusdtkrw","upbitUSDT","len","coin","exceptionArr","exceptionflag","map","symbolName","indexOf","slice","binanBTCSym","binanBTCPrice","calKobinanBTC","binBTC_start_per","binanUSDTSym","binanUSDTPrice","calKoUSDT","binUSDT_start_per","binanBNBSym","binanBNBPrice","calKoBUSD","binBUSD_start_per","per","read","keyread","maxPer","minPer","BTCper","totalPer","totalminPer","Number","MAX_SAFE_INTEGER","sortExchange","exchange","lastminExchange","lastmaxExchange","minmaxExchange","maxExchange","minExchange","push","Array","from","Set","result","length","upbitWithdraw","bithumbWithdraw","binanceWithdraw","testper","coinStateCount","coinStringMake","coinOne","dataFactory","arrCount","upbitSym","bithumbSym","upbitBTC","bithumbBTC","sort","next","prev","KrwPrice","upbitInitNames","stringdd","imgsrc","bithumbInitNames"],"mappings":"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","sourcesContent":["\nimport axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\n\nconst pricereturnFloat = (price) => {\n    let data = parseFloat(price);\n    if (data < 1.0) {\n        return data.toFixed(8);\n    }\n    else {\n        return data.toFixed(1);\n    }\n}\n\nconst coinListDataUtils = {\n    kucoinAllNames: (names) => {\n        names.forEach(coinlist => {\n            var coinName = coinlist.symbol.split('-')[0];\n            var type = coinlist.symbol.split('-')[1];\n\n            var newCoin = false;\n            if (type !== 'ETH') {\n                CoinMarketData.find((name) => {\n                    if (name.symbol === coinName) {\n                        newCoin = true;\n                    }\n                });\n                /*if (newCoin === false) {\n                    console.log(coinName, type);\n                }*/\n            }\n        });\n    },\n\n    upbitAllNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            data[name.market] = {\n                korean: name.korean_name,\n            };\n        })\n        return data;\n    },\n    upbitPriceNames: (names, state) => {\n        const coinStateDatas = state.Coin.upbitTotalNames.data;\n        names.forEach(name => {\n            coinStateDatas[name.market] = {\n                korean: pricereturnFloat(name.trade_price),\n            };\n        })\n        return coinStateDatas;\n    },\n\n    binanceNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            }\n        })\n        return data;\n    },\n    bithumbKRWNames: (names) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            data[name + \"_KRW\"] = {\n                korean: pricereturnFloat(names[name].closing_price),\n            };\n        })\n        return data;\n    },\n    bithumbBTCNames: (names, state) => {\n        const coinStateDatas = state.Coin.bithumbTotalNames.data;\n        Object.keys(names).forEach(name => {\n            coinStateDatas[name + \"_BTC\"] = {\n                korean: pricereturnFloat(names[name].closing_price),\n            };\n        })\n        return coinStateDatas;\n    }\n};\n\nconst coinReadDataUtils = {\n    mixExchangeUpdates: (one_names, two_names, three_names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        const TOPmarketNames = state.Coin.TOPmarketNames;\n        const TOPmarketString = state.Coin.TOPmarketString;\n        //✅ bithumb\n        two_names.forEach(name => {\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = pricereturnFloat(name.closePrice);\n            var sortOrder = [];\n            var cal, calper;\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === \"KRW\") {\n\n                if (sortOrder[0] === 'upbitSym') {\n                    calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2)\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice,\n                    bithumbKRW_start_per: calper\n                }\n\n            }\n            else if (moneySym === \"BTC\") {\n\n                var origin = parseFloat(coinStateDatas['BTC'].bithumbPrice);\n                cal = (origin * parseFloat(nowPrice)).toFixed(2);\n                if (shortSym === 'MKR')\n                    console.log('MKR', coinStateDatas['BTC'].bithumbPrice, nowPrice, cal);\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice,\n                    calKobithumbBTC: cal\n                }\n            }\n        });\n        //✅ upbit\n        one_names.forEach(name => {\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = pricereturnFloat(name.trade_price);\n            var sortOrder = [];\n            var cal, calper;\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0] && !sortOrder[1]) {\n                    sortOrder.splice(0, 2);\n                }\n                else if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n            } else if (moneySym === \"USDT\") {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitUSDT') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[1] === 'upbitBTC') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else {\n                    calper = \"Prepare\";\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice,\n\n                    upbitUSDT_start_per: calper,\n                    calKoupbitUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n                var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n                cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = 'prepare';\n\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice,\n                    //!\n                    calKoupbitBTC: cal,\n                    upbitBTC_start_per: calper\n                }\n            }\n\n            if (coinStateDatas['BTC'].upbitPrice) {\n                //@\n                var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n\n                coinStateDatas['USDT'] = {\n                    ...coinStateDatas['USDT'],\n\n                    upbitUSDT: 'USDTKRW',\n                    upbitUSDTPrice: upbitusdtkrw\n                }\n            }\n        });\n\n\n        //✅ binance\n        three_names.forEach(name => {\n            let nowPrice = pricereturnFloat(name.price);\n            var sortOrder = [];\n            var len, cal, calper, coin;\n            let moneySym;\n            let exceptionArr = ['VENUSDT', 'VENBTC', , 'MBLBTC',\n                'TUSDBTC', 'DAIBTC', 'REPBUSD', 'STORJBUSD', 'DENTBTC', 'MFTBTC',\n                'SUNBTC', 'BTTBTC', 'COCOSBTC', 'PAXBTC', 'PAXUSDT', 'PAXBUSD',\n                'BCHSVBTC', 'BCHSVUSDT', 'BCCBTC', 'BCCUSDT', 'HOTBTC', 'BCHABCBTC',\n                'BCHABCUSDT', 'BCHABCBUSD', 'STORMBTC', 'STORMUSDT', 'LENDBTC', 'LENDUSDT', 'LENDBUSD',\n                'ERDBTC', 'ERDUSDT', 'ERDBUSD', 'MCOBTC', 'MCOUSDT', 'STRATBTC', 'STRATUSDT', 'STRATBUSD',\n                'VTHOBUSD', 'DCRBUSD', 'NPXSBTC', 'NPXSUSDT', 'BLZBUSD', 'WNXMBUSD', 'AIONBUSD', 'KMDBUSD',\n                'XZCBT', 'XZCUSDT', 'IRISBUSD', 'HCBTC', 'HCUSDT', 'KEYBTC', 'KEYUSDT', 'TROYBTC', 'SUSDBTC',\n                'TRUBUSD', 'BOOTBTC', 'BOTBUSD', 'PXGBUSD', 'BTSBUSD', 'RENBTCBTC', 'RENBTCETH'\n            ];\n            let exceptionflag = false;\n            exceptionArr.map((symbolName) => {\n                if (name.symbol === symbolName) {\n                    exceptionflag = true\n                    return;\n                }\n            })\n            if (exceptionflag === true)\n                return coinStateDatas;\n\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                len = name.symbol.indexOf('BTC');\n                moneySym = 'BTC';\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                len = name.symbol.indexOf('USDT');\n                moneySym = 'USDT';\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                len = name.symbol.indexOf('BUSD');\n                moneySym = 'BUSD';\n            }\n            coin = name.symbol.slice(0, len);\n\n            if (coinStateDatas[coin]) {\n                Object.keys(coinStateDatas[coin]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0] && !sortOrder[1]) {\n                    sortOrder.splice(0, 2);\n                }\n                else if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === 'BTC') {\n                cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBTCSym: name.symbol,\n                        binanBTCPrice: nowPrice,\n                        calKobinanBTC: cal,\n                        binBTC_start_per: calper\n                    }\n                }\n            } else if (moneySym === 'USDT') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanUSDTSym: name.symbol,\n                        binanUSDTPrice: nowPrice,\n                        calKoUSDT: cal,\n                        binUSDT_start_per: calper,\n                    }\n                }\n            } else if (moneySym === 'BUSD') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBNBSym: name.symbol,\n                        binanBNBPrice: nowPrice,\n                        calKoBUSD: cal,\n                        binBUSD_start_per: calper,\n                    }\n                }\n            }\n            //📌 EXCEPTION\n            if (name.symbol === 'BTCBUSD') {\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanBNBSym: name.symbol,\n                    binanBNBPrice: nowPrice\n                }\n            } else if (name.symbol === 'BTCUSDT') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanUSDTSym: name.symbol,\n                    binanUSDTPrice: nowPrice,\n                    calKoUSDT: cal,\n                    per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n                }\n            }\n        });\n\n        //✅ Max per search\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n            var maxPer = 0.0;\n            var minPer = 0.0;\n            keyread.forEach((name) => {\n                var per;\n                if (name === 'bithumbKRW_start_per') {\n                    per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n                }\n                else if (name === 'binBUSD_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n                } else if (name === 'upbitBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n                } else if (name === 'upbitUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n                } else if (name === 'BTCper') {\n                    per = parseFloat(coinStateDatas[coin].BTCper);\n                } else if (name === 'binUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n                }\n                else if (name === 'binBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n                }\n                if (per > maxPer) {\n                    maxPer = per;\n                }\n                if (per < minPer) {\n                    minPer = per;\n                }\n            })\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                totalPer: maxPer,\n                totalminPer: minPer\n            }\n        });\n\n        //📦 v2\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n            var maxPer = 0.0;\n            var minPer = Number.MAX_SAFE_INTEGER;\n            var sortExchange = [];\n            var exchange;\n            var lastminExchange, lastmaxExchange;\n            var minmaxExchange, maxExchange, minExchange;\n\n            keyread.forEach((name) => {\n                var price;\n                if (name === 'upbitPrice') {\n                    price = parseFloat(coinStateDatas[coin].upbitPrice);\n                    sortExchange.push('upbit');\n                    exchange = 'upbitWithdraw';\n                    minmaxExchange = 'upbitKRW';\n                }\n                else if (name === 'bithumbPrice') {\n                    price = parseFloat(coinStateDatas[coin].bithumbPrice);\n                    sortExchange.push('bithumb');\n                    exchange = 'bithumbWithdraw';\n                    minmaxExchange = 'bithumbKRW';\n                }\n                else if (name === 'calKoupbitBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n                    sortExchange.push('upbit');\n                    exchange = 'upbitWithdraw';\n                    minmaxExchange = 'upbitBTC';\n                }\n                else if (name === 'calKobithumbBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKobithumbBTC);\n                    //ok\n                    sortExchange.push('bithumb');\n                    exchange = 'bithumbWithdraw';\n                    minmaxExchange = 'bithumbBTC';\n                } else if (name === 'calKobinanBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKobinanBTC);\n                    sortExchange.push('binance');\n                    exchange = 'binanceWithdraw';\n                    minmaxExchange = 'binanceBTC';\n                } else if (name === 'calKoupbitUSDT') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitUSDT);\n                    sortExchange.push('upbit');\n                    minmaxExchange = 'upbitUSDT';\n                } else if (name === 'calKoUSDT') {\n                    price = parseFloat(coinStateDatas[coin].calKoUSDT);\n                    sortExchange.push('binance');\n                    exchange = 'binanceWithdraw';\n                    minmaxExchange = 'binanceUSDT';\n                } else if (name === 'calKoBUSD') {\n                    price = parseFloat(coinStateDatas[coin].calKoBUSD);\n                    sortExchange.push('binance');\n                    exchange = 'binanceWithdraw';\n                    minmaxExchange = 'binanceBUSD';\n                }\n\n                if (price > maxPer) {\n                    maxPer = price;\n                    maxExchange = minmaxExchange\n                    lastmaxExchange = exchange;\n                }\n                if (price < minPer) {\n                    minPer = price;\n                    minExchange = minmaxExchange\n                    lastminExchange = exchange;\n                }\n            })\n            sortExchange = Array.from(new Set(sortExchange));\n\n            if (coin === 'MKR') {\n                console.log('MKR price check', minPer, maxPer, coinStateDatas['MKR']);\n            }\n\n\n            var result = 0.0;\n            if (sortExchange.length <= 1) {\n                minPer = 0;\n                maxPer = 0;\n                result = 0;\n            }\n            else {\n                CoinMarketData.find((name) => {\n                    if (name.symbol === coin) {\n                        if (lastminExchange === 'bithumbWithdraw' && lastmaxExchange === 'bithumbWithdraw') {\n                            minPer = 0;\n                            maxPer = 0;\n                            result = 0;\n                            return;\n                        }\n                        else if (lastminExchange === 'upbitWithdraw') {\n                            if (name.upbitWithdraw !== 'NO')\n                                minPer = (parseFloat(name.upbitWithdraw) * parseFloat(minPer)) + minPer;\n                            else {\n                                minPer = 0;\n                                maxPer = 0;\n                                result = 0;\n                                return;\n                            }\n                        } else if (lastminExchange === 'bithumbWithdraw') {\n                            minPer = (parseFloat(name.bithumbWithdraw) * parseFloat(minPer)) + minPer;\n                        }\n                        else if (lastminExchange === 'binanceWithdraw') {\n                            if (name.upbitWithdraw !== 'NO')\n                                minPer = (parseFloat(name.binanceWithdraw) * parseFloat(minPer)) + minPer;\n                            else {\n                                minPer = 0;\n                                maxPer = 0;\n                                result = 0;\n                                return;\n                            }\n                        }\n                    }\n                })\n                if (!(minPer <= 0 || maxPer === 0))\n                    result = ((maxPer - minPer) / minPer * 100).toFixed(1);\n                else {\n                    result = 0;\n                }\n            }\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                testper: result,\n                symbol: coin,\n                minExchange: minExchange,\n                maxExchange: maxExchange,\n            }\n        });\n\n        //!\n        TOPmarketNames.splice(0);\n        var coinStateCount = 0;\n        var coinStringMake = \"\";\n        Object.keys(coinStateDatas).forEach((coinOne) => {\n            if (coinStateDatas[coinOne].testper > 0) {\n                coinStringMake += coinOne + \",\";\n                var dataFactory = [];\n                var keyread = Object.keys(coinStateDatas[coinOne])\n                var arrCount = 0;\n                keyread.forEach((name) => {\n                    if (name === 'upbitPrice') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].upbitSym,\n                            'exchange': 'upbit',\n                            'OriginPrice': coinStateDatas[coinOne].upbitPrice,\n                            'KrwPrice': coinStateDatas[coinOne].upbitPrice\n\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'bithumbSym') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].bithumbSym,\n                            'exchange': 'bithumb',\n                            'OriginPrice': coinStateDatas[coinOne].bithumbPrice,\n                            'KrwPrice': coinStateDatas[coinOne].bithumbPrice\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoupbitBTC') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].upbitBTC,\n                            'exchange': 'upbit',\n                            'OriginPrice': coinStateDatas[coinOne].upbitBTCPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoupbitBTC\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKobithumbBTC') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].bithumbBTC,\n                            'exchange': 'bithumb',\n                            'OriginPrice': coinStateDatas[coinOne].bithumbBTCPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKobithumbBTC\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoupbitUSDT') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].upbitUSDT,\n                            'exchange': 'upbit',\n                            'OriginPrice': coinStateDatas[coinOne].upbitUSDTPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoupbitUSDT\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKobinanBTC') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].binanBTCSym,\n                            'exchange': 'binance',\n                            'OriginPrice': coinStateDatas[coinOne].binanBTCPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKobinanBTC\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoUSDT') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].binanUSDTSym,\n                            'exchange': 'binance',\n                            'OriginPrice': coinStateDatas[coinOne].binanUSDTPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoUSDT\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoBUSD') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].binanBNBSym,\n                            'exchange': 'binance',\n                            'OriginPrice': coinStateDatas[coinOne].binanBNBPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoBUSD\n                        }\n                        arrCount++;\n                    }\n\n                });\n                //console.log('before', dataFactory); //1 2 3 4 5 \n                dataFactory = dataFactory.sort((next, prev) => {\n\n                    if (parseFloat(next.KrwPrice) > parseFloat(prev.KrwPrice)) {\n                        return -1;\n                    } else {\n                        return 0;\n                    }\n                })\n\n                TOPmarketNames[coinStateCount] = dataFactory;//coinStateDatas[coinOne]\n                coinStateCount++;\n            }\n        })\n        TOPmarketString[0] = { 'ALL': coinStringMake }\n\n        return coinStateDatas;\n    },\n    //\n    upbitInitNames: (names, state) => {\n\n        var stringdd = \"\";\n        CoinMarketData.find((name) => {\n            stringdd += name.symbol + \" \"\n        });\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n\n            if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                }\n            } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                }\n            }\n        })\n        data['USDT'] = {\n            ...data['USDT'],\n            upbitUSDTPrice: (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1),\n            upbitUSDT: 'USDTKRW',\n        }\n\n        Object.keys(names).forEach(name => {\n\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n            let imgsrc = \"\";\n            CoinMarketData.find((coin) => {\n                if (coin.symbol === shortSym) {\n                    imgsrc = coin.imgsrc;\n                }\n            })\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                    imgsrc: imgsrc\n                }\n            } else if (moneySym === \"USDT\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                    imgsrc: imgsrc,\n                    calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n                }\n            } else if (moneySym === \"BTC\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTCPrice: names[name].korean,\n                    upbitBTC: name,\n                    imgsrc: imgsrc,\n                    calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        });\n        return data;\n    },\n    bithumbInitNames: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"_\")[0];\n            let moneySym = name.split(\"_\")[1];\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: names[name].korean,\n                    bithumbSym: name,\n                }\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: names[name].korean,\n                    bithumbBTC: name,\n                    calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        })\n\n\n        //!\n\n\n        return coinStateDatas;\n    }\n};\n\n\nexport {\n    coinListDataUtils,\n    coinReadDataUtils\n}"]},"metadata":{},"sourceType":"module"}