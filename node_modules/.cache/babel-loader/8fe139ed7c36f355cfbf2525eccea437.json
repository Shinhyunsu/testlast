{"ast":null,"code":"import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\nimport { throttle } from \"lodash\";\nimport { coinReadDataUtils } from \"./utils\";\nimport axios from \"axios\";\nimport { binancecoinApi, upbitoinApi } from \"../Api/api\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    var res;\n    const state = yield select();\n\n    if (type === \"GET_UPBIT_MARKET_PRICE_INIT\") {\n      var coinString;\n      Object.keys(state.Coin.upbitTotalNames.data).map(coin => {\n        coinString += coin + \",\";\n      }); //✅ coinString 내용을 복사 해서 api getMarketPriceCodes 에 붙여넣기 함.... ;;\n\n      coinString = coinString.slice(9, -1);\n      res = yield call(api, action.payload);\n    } else {\n      res = yield call(api, action.payload);\n    }\n\n    try {\n      const state = yield select();\n\n      if (type === \"GET_UPBIT_MARKET_NAMES\" || type === \"GET_UPBIT_MARKET_PRICE_INIT\" || type === \"GET_BINANCE_MARKET_NAMES\") {\n        yield put({\n          type: SUCCESS,\n          payload: dataMaker(res.data, state)\n        });\n      } else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\") {\n        //console.log(res.data.data);\n        yield put({\n          type: SUCCESS,\n          payload: dataMaker(res.data.data, state)\n        });\n      }\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n      throw e;\n    }\n  };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    try {\n      const state = yield select();\n      yield put({\n        type: SUCCESS,\n        payload: dataMaker(action.payload, state)\n      });\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n      throw e;\n    }\n  };\n}; // requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\n\n\nconst requestActions = (type, key) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return (state, action) => {\n    //console.log(state, action);\n    switch (action.type) {\n      case SUCCESS:\n        //console.log(15);\n        return reducerUtils.success(state, action.payload, key);\n\n      case ERROR:\n        return reducerUtils.error(state, action.payload, key);\n\n      default:\n        return state;\n    }\n  };\n};\n\nconst reducerUtils = {\n  success: (state, payload, key) => {\n    return { ...state,\n      [key]: {\n        data: payload,\n        error: false\n      }\n    };\n  },\n  error: (state, error, key) => ({ ...state,\n    [key]: { ...state[key],\n      error: error\n    }\n  })\n};\n\nconst createUpbitSocket = () => {\n  const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n  client.binaryType = \"arraybuffer\";\n  return client;\n};\n\nconst createBithumbSocket = () => {\n  const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n  client.binaryType = \"arraybuffer\";\n  return client;\n}; // 소켓 연결용\n\n\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n  //console.log(\"action\", action);\n  return eventChannel(emit => {\n    socket.onopen = () => {\n      //if (type === \"CONNECT_UPBIT_SOCKET\") {\n      socket.send(JSON.stringify([{\n        ticket: \"coinbread-clone\"\n      }, {\n        type: connectType,\n        codes: action\n      }])); //} \n\n      /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n          socket.send(\n              JSON.stringify(\n                  { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n              )\n          );\n      }*/\n    };\n\n    socket.onmessage = evt => {\n      //upbit\n      //console.log(\"upbit\", evt);\n      //if (type === \"CONNECT_UPBIT_SOCKET\") {\n      const enc = new encoding.TextDecoder(\"utf-8\");\n      const data = JSON.parse(enc.decode(evt.data));\n      emit(data); //} \n\n      /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n          emit(JSON.parse(evt.data));\n      }*/\n    };\n\n    socket.onerror = evt => {\n      console.log(\"error\", evt);\n      emit(evt);\n      emit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.close();\n    };\n\n    return unsubscribe;\n  }, buffer || buffers.none());\n};\n\nconst bitconnectSocekt = (socket, connectType, type, action, buffer) => {\n  //console.log(type);\n  return eventChannel(eemit => {\n    var count = 0;\n\n    socket.onopen = () => {\n      socket.send(JSON.stringify({\n        type: connectType,\n        symbols: action,\n        tickTypes: [\"MID\"]\n      }));\n    };\n\n    socket.onmessage = evt => {\n      //console.log(evt.data);\n      const data = JSON.parse(evt.data);\n\n      if (data && data['type'] === 'ticker') {\n        /*if (count === 0) {\n            socket.send(\n                JSON.stringify(\n                    { type: connectType, symbols: [\"ETH_KRW\"], tickTypes: [\"MID\"] }\n                )\n            );\n            count = 1;\n            console.log(\"0\", data['content']);\n            eemit(data['content']);\n        }\n        else if (count === 1) {\n            socket.send(\n                JSON.stringify(\n                    { type: connectType, symbols: [\"BTC_KRW\"], tickTypes: [\"MID\"] }\n                )\n            );\n            count = 0;\n            console.log(\"1\", data['content']);\n            eemit(data['content']);\n        }*/\n        eemit(data['content']);\n      }\n    };\n\n    socket.onerror = evt => {\n      console.log(\"error\", evt);\n      eemit(evt);\n      eemit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.close();\n    };\n\n    return unsubscribe;\n  }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    const state = yield select();\n    const upbitTotalNames = Object.keys(state.Coin.upbitTotalNames.data);\n    const bithumbTotalNames = Object.keys(state.Coin.bithumbTotalNames.data);\n    var client;\n    var bitclient;\n    var clientChannel; //✅ new\n\n    var bitclientChannel;\n    client = yield call(createUpbitSocket);\n    bitclient = yield call(createBithumbSocket); //console.log(upbitTotalNames);\n\n    clientChannel = yield call(connectSocekt, client, connectType, type, upbitTotalNames, buffers.expanding(500)); //✅ new\n\n    bitclientChannel = yield call(bitconnectSocekt, bitclient, connectType, type, bithumbTotalNames, buffers.expanding(500));\n\n    try {\n      while (true) {\n        const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n\n        const bitdatas = yield flush(bitclientChannel);\n        var sortedDATA;\n        var sortedData;\n\n        if (datas.length) {\n          //console.log(datas);\n          var sortedObj = {};\n          datas.forEach(data => {\n            if (sortedObj[data.code]) {\n              // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n              sortedObj[data.code] = sortedObj[data.code].timestamp > data.timestamp ? sortedObj[data.code] : data;\n            } else {\n              sortedObj[data.code] = data;\n            }\n\n            sortedObj[data.code] = data; //console.log(sortedObj[data.code]);\n          });\n          sortedDATA = Object.keys(sortedObj).map(data => sortedObj[data]); //yield put({ type: SUCCESS, payload: dataMaker(sortedDATA, state) });\n\n          if (bitdatas.length) {\n            var sortedObj = {};\n            var binanceObj; //console.log(bitdatas);\n\n            bitdatas.forEach(data => {\n              if (sortedObj[data.code]) {\n                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                sortedObj[data.symbol] = sortedObj[data.symbol].time > data.time ? sortedObj[data.symbol] : data;\n              } else {\n                sortedObj[data.symbol] = data;\n              }\n\n              sortedObj[data.symbol] = data; //console.log(sortedObj[data.symbol]);\n              //console.log(sortedObj);\n            });\n            sortedData = Object.keys(sortedObj).map(data => sortedObj[data]);\n            binanceObj = yield call(binancecoinApi.getMarketCodes); //geckoObj = yield call()\n\n            yield put({\n              type: SUCCESS,\n              payload: coinReadDataUtils.mixExchangeUpdates(sortedDATA, sortedData, binanceObj.data, state)\n            });\n          }\n        }\n\n        yield delay(500); // 500ms 동안 대기\n      }\n    } catch (e) {\n      console.log(e);\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n    } finally {\n      clientChannel.close();\n    }\n  };\n};\n\nconst bitcreateConnectSocketSaga = (type, connectType, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`; //console.log(\"11\");\n\n  return function* (action = {}) {//console.log(\"afsdf\");\n\n    /*var client;\n    var clientChannel;\n    if (type === \"CONNECT_UPBIT_SOCKET\")\n        client = yield call(createUpbitSocket);\n    else if (type === \"CONNECT_BITHUMB_SOCKET\")\n        client = yield call(createBithumbSocket);\n     clientChannel = yield call(\n        bitconnectSocekt,\n        client,\n        connectType,\n        type,\n        action,\n        buffers.expanding(500)\n    );\n     try {\n        while (true) {\n            const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n            const state = yield select();\n             if (datas.length) {\n                const sortedObj = {};\n                datas.forEach((data) => {\n                    if (type === \"CONNECT_UPBIT_SOCKET\") {\n                        if (sortedObj[data.code]) {\n                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                            sortedObj[data.code] =\n                                sortedObj[data.code].timestamp > data.timestamp\n                                    ? sortedObj[data.code]\n                                    : data;\n                        } else {\n                            sortedObj[data.code] = data;\n                        }\n                        sortedObj[data.code] = data;\n                    }\n                    else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                        console.log(\"check\");\n                        if (sortedObj[data.content]) {\n                            sortedObj[data.content] =\n                                sortedObj[data.content].time > data.time\n                                    ? sortedObj[data.content]\n                                    : data;\n                        } else {\n                            sortedObj[data.content] = data;\n                        }\n                        sortedObj[data.content] = data;\n                    }\n                });\n                 const sortedData = Object.keys(sortedObj).map(\n                    (data) => sortedObj[data]\n                );\n                 yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n            }\n             yield delay(500); // 500ms 동안 대기\n        }\n    } catch (e) {\n        yield put({ type: ERROR, payload: e });\n    } finally {\n        clientChannel.close();\n    }*/\n    //};\n  };\n};\n\nexport { createRequestSaga, requestActions, createConnectSocketSaga, createInitRequestSaga, bitcreateConnectSocketSaga };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/asyncUtil.js"],"names":["call","put","select","flush","delay","w3cwebsocket","W3CWebSocket","buffers","eventChannel","END","encoding","throttle","coinReadDataUtils","axios","binancecoinApi","upbitoinApi","createRequestSaga","type","api","dataMaker","SUCCESS","ERROR","action","res","state","coinString","Object","keys","Coin","upbitTotalNames","data","map","coin","slice","payload","e","createInitRequestSaga","requestActions","key","reducerUtils","success","error","createUpbitSocket","client","binaryType","createBithumbSocket","connectSocekt","socket","connectType","buffer","emit","onopen","send","JSON","stringify","ticket","codes","onmessage","evt","enc","TextDecoder","parse","decode","onerror","console","log","unsubscribe","close","none","bitconnectSocekt","eemit","count","symbols","tickTypes","createConnectSocketSaga","bithumbTotalNames","bitclient","clientChannel","bitclientChannel","expanding","datas","bitdatas","sortedDATA","sortedData","length","sortedObj","forEach","code","timestamp","binanceObj","symbol","time","getMarketCodes","mixExchangeUpdates","bitcreateConnectSocketSaga"],"mappings":"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ACV,KAAd;AACH;AACJ,GA1GD;AA2GH,CA/GD;;AAkHA,MAAM2B,0BAA0B,GAAG,CAAC7E,IAAD,EAAO+B,WAAP,EAAoB7B,SAApB,KAAkC;AACjE,QAAMC,OAAO,GAAI,GAAEH,IAAK,UAAxB;AACA,QAAMI,KAAK,GAAI,GAAEJ,IAAK,QAAtB,CAFiE,CAGjE;;AAEA,SAAO,WAAWK,MAAM,GAAG,EAApB,EAAwB,CAE3B;;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOQ;AACH,GApED;AAqEH,CA1ED;;AA8EA,SACIN,iBADJ,EAEIqB,cAFJ,EAGIqC,uBAHJ,EAIItC,qBAJJ,EAKI0D,0BALJ","sourcesContent":["import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\n\nimport { throttle } from \"lodash\";\nimport { coinReadDataUtils } from \"./utils\";\n\nimport axios from \"axios\";\nimport { binancecoinApi, upbitoinApi } from \"../Api/api\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n\n    return function* (action = {}) {\n        var res;\n        const state = yield select();\n\n        if (type === \"GET_UPBIT_MARKET_PRICE_INIT\") {\n            var coinString;\n            Object.keys(state.Coin.upbitTotalNames.data).map((coin) => {\n\n                coinString += coin + \",\"\n            });\n            //✅ coinString 내용을 복사 해서 api getMarketPriceCodes 에 붙여넣기 함.... ;;\n            coinString = coinString.slice(9, -1);\n            res = yield call(api, action.payload);\n        }\n        else {\n            res = yield call(api, action.payload);\n        }\n        try {\n            const state = yield select();\n            if (type === \"GET_UPBIT_MARKET_NAMES\" || type === \"GET_UPBIT_MARKET_PRICE_INIT\" || type === \"GET_BINANCE_MARKET_NAMES\") {\n                yield put({ type: SUCCESS, payload: dataMaker(res.data, state) });\n            }\n            else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\") {\n                //console.log(res.data.data);\n                yield put({ type: SUCCESS, payload: dataMaker(res.data.data, state) });\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        try {\n            const state = yield select();\n            yield put({ type: SUCCESS, payload: dataMaker(action.payload, state) });\n\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\n// requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\nconst requestActions = (type, key) => {\n    const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n\n    return (state, action) => {\n        //console.log(state, action);\n        switch (action.type) {\n            case SUCCESS:\n                //console.log(15);\n                return reducerUtils.success(state, action.payload, key);\n            case ERROR:\n                return reducerUtils.error(state, action.payload, key);\n            default:\n                return state;\n        }\n    };\n};\n\nconst reducerUtils = {\n    success: (state, payload, key) => {\n        return {\n            ...state,\n            [key]: {\n                data: payload,\n                error: false,\n            },\n        };\n    },\n    error: (state, error, key) => ({\n        ...state,\n        [key]: {\n            ...state[key],\n            error: error,\n        },\n    }),\n};\n\nconst createUpbitSocket = () => {\n    const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\nconst createBithumbSocket = () => {\n    const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\n\n\n// 소켓 연결용\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(\"action\", action);\n    return eventChannel((emit) => {\n        socket.onopen = () => {\n            //if (type === \"CONNECT_UPBIT_SOCKET\") {\n            socket.send(\n                JSON.stringify([\n                    { ticket: \"coinbread-clone\" },\n                    { type: connectType, codes: action },\n                ])\n            );\n            //} \n            /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                socket.send(\n                    JSON.stringify(\n                        { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n                    )\n                );\n            }*/\n        };\n        socket.onmessage = (evt) => {\n            //upbit\n            //console.log(\"upbit\", evt);\n            //if (type === \"CONNECT_UPBIT_SOCKET\") {\n            const enc = new encoding.TextDecoder(\"utf-8\");\n            const data = JSON.parse(enc.decode(evt.data));\n            emit(data);\n            //} \n            /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                emit(JSON.parse(evt.data));\n            }*/\n        };\n\n        socket.onerror = (evt) => {\n            console.log(\"error\", evt);\n            emit(evt);\n            emit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst bitconnectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(type);\n\n    return eventChannel((eemit) => {\n        var count = 0;\n        socket.onopen = () => {\n            socket.send(\n                JSON.stringify(\n                    { type: connectType, symbols: action, tickTypes: [\"MID\"] }\n                )\n            );\n        };\n        socket.onmessage = (evt) => {\n            //console.log(evt.data);\n            const data = JSON.parse(evt.data)\n            if (data && data['type'] === 'ticker') {\n                /*if (count === 0) {\n                    socket.send(\n                        JSON.stringify(\n                            { type: connectType, symbols: [\"ETH_KRW\"], tickTypes: [\"MID\"] }\n                        )\n                    );\n                    count = 1;\n                    console.log(\"0\", data['content']);\n                    eemit(data['content']);\n                }\n                else if (count === 1) {\n                    socket.send(\n                        JSON.stringify(\n                            { type: connectType, symbols: [\"BTC_KRW\"], tickTypes: [\"MID\"] }\n                        )\n                    );\n                    count = 0;\n                    console.log(\"1\", data['content']);\n                    eemit(data['content']);\n                }*/\n                eemit(data['content']);\n            }\n\n        };\n\n        socket.onerror = (evt) => {\n            console.log(\"error\", evt);\n            eemit(evt);\n            eemit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        const state = yield select();\n\n        const upbitTotalNames = Object.keys(state.Coin.upbitTotalNames.data);\n        const bithumbTotalNames = Object.keys(state.Coin.bithumbTotalNames.data);\n\n        var client;\n        var bitclient;\n        var clientChannel;\n        //✅ new\n        var bitclientChannel;\n\n\n        client = yield call(createUpbitSocket);\n\n        bitclient = yield call(createBithumbSocket);\n        //console.log(upbitTotalNames);\n        clientChannel = yield call(\n            connectSocekt,\n            client,\n            connectType,\n            type,\n            upbitTotalNames,\n            buffers.expanding(500)\n        );\n\n        //✅ new\n        bitclientChannel = yield call(\n            bitconnectSocekt,\n            bitclient,\n            connectType,\n            type,\n            bithumbTotalNames,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const bitdatas = yield flush(bitclientChannel);\n\n                var sortedDATA;\n                var sortedData;\n\n                if (datas.length) {\n                    //console.log(datas);\n                    var sortedObj = {};\n                    datas.forEach((data) => {\n                        if (sortedObj[data.code]) {\n                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                            sortedObj[data.code] =\n                                sortedObj[data.code].timestamp > data.timestamp\n                                    ? sortedObj[data.code]\n                                    : data;\n                        } else {\n                            sortedObj[data.code] = data;\n                        }\n                        sortedObj[data.code] = data;\n                        //console.log(sortedObj[data.code]);\n                    });\n\n                    sortedDATA = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n                    //yield put({ type: SUCCESS, payload: dataMaker(sortedDATA, state) });\n\n                    if (bitdatas.length) {\n                        var sortedObj = {};\n                        var binanceObj;\n                        //console.log(bitdatas);\n                        bitdatas.forEach((data) => {\n                            if (sortedObj[data.code]) {\n                                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                sortedObj[data.symbol] =\n                                    sortedObj[data.symbol].time > data.time\n                                        ? sortedObj[data.symbol]\n                                        : data;\n                            } else {\n                                sortedObj[data.symbol] = data;\n                            }\n                            sortedObj[data.symbol] = data;\n                            //console.log(sortedObj[data.symbol]);\n                            //console.log(sortedObj);\n                        });\n                        sortedData = Object.keys(sortedObj).map(\n                            (data) => sortedObj[data]\n\n                        );\n                        binanceObj = yield call(binancecoinApi.getMarketCodes)\n                        //geckoObj = yield call()\n\n                        yield put({ type: SUCCESS, payload: coinReadDataUtils.mixExchangeUpdates(sortedDATA, sortedData, binanceObj.data, state) });\n\n                    }\n\n\n                }\n                yield delay(500); // 500ms 동안 대기\n\n            }\n        } catch (e) {\n            console.log(e);\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }\n    };\n};\n\n\nconst bitcreateConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n    //console.log(\"11\");\n\n    return function* (action = {}) {\n\n        //console.log(\"afsdf\");\n        /*var client;\n        var clientChannel;\n        if (type === \"CONNECT_UPBIT_SOCKET\")\n            client = yield call(createUpbitSocket);\n        else if (type === \"CONNECT_BITHUMB_SOCKET\")\n            client = yield call(createBithumbSocket);\n\n        clientChannel = yield call(\n            bitconnectSocekt,\n            client,\n            connectType,\n            type,\n            action,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const state = yield select();\n\n                if (datas.length) {\n                    const sortedObj = {};\n                    datas.forEach((data) => {\n                        if (type === \"CONNECT_UPBIT_SOCKET\") {\n                            if (sortedObj[data.code]) {\n                                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                sortedObj[data.code] =\n                                    sortedObj[data.code].timestamp > data.timestamp\n                                        ? sortedObj[data.code]\n                                        : data;\n                            } else {\n                                sortedObj[data.code] = data;\n                            }\n                            sortedObj[data.code] = data;\n                        }\n                        else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                            console.log(\"check\");\n                            if (sortedObj[data.content]) {\n                                sortedObj[data.content] =\n                                    sortedObj[data.content].time > data.time\n                                        ? sortedObj[data.content]\n                                        : data;\n                            } else {\n                                sortedObj[data.content] = data;\n                            }\n                            sortedObj[data.content] = data;\n                        }\n                    });\n\n                    const sortedData = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n\n                    yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n                }\n\n                yield delay(500); // 500ms 동안 대기\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }*/\n        //};\n    }\n};\n\n\n\nexport {\n    createRequestSaga,\n    requestActions,\n    createConnectSocketSaga,\n    createInitRequestSaga,\n    bitcreateConnectSocketSaga\n}"]},"metadata":{},"sourceType":"module"}