{"ast":null,"code":"import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\nimport { bithumbcoinApi } from \"../Api/api\";\nimport { throttle } from \"lodash\";\nimport { compose } from \"redux\";\nimport { coinReadDataUtils } from \"./utils\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    /*var res;\n    var ress;\n    if (type === \"GET_BITHUMB_MARKET_NAMES\") {\n        res = yield call(bithumbcoinApi.getKRWMarketCodes);\n        ress = yield call(bithumbcoinApi.getBTCMarketCodes);\n    }*/\n    //✅ 업비트\n    const res = yield call(api, action.payload);\n\n    try {\n      const state = yield select();\n      if (type === \"GET_UPBIT_MARKET_NAMES\") yield put({\n        type: SUCCESS,\n        payload: dataMaker(res.data, state)\n      });else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\") yield put({\n        type: SUCCESS,\n        payload: dataMaker(res.data.data, state)\n      });\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n      throw e;\n    }\n  };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    try {\n      const state = yield select();\n      yield put({\n        type: SUCCESS,\n        payload: dataMaker(action.payload, state)\n      });\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n      throw e;\n    }\n  };\n}; // requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\n\n\nconst requestActions = (type, key) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return (state, action) => {\n    //console.log(state, action);\n    switch (action.type) {\n      case SUCCESS:\n        //console.log(15);\n        return reducerUtils.success(state, action.payload, key);\n\n      case ERROR:\n        return reducerUtils.error(state, action.payload, key);\n\n      default:\n        return state;\n    }\n  };\n};\n\nconst reducerUtils = {\n  success: (state, payload, key) => {\n    return { ...state,\n      [key]: {\n        data: payload,\n        error: false\n      }\n    };\n  },\n  error: (state, error, key) => ({ ...state,\n    [key]: { ...state[key],\n      error: error\n    }\n  })\n};\n\nconst createUpbitSocket = () => {\n  const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n  client.binaryType = \"arraybuffer\";\n  return client;\n};\n\nconst createBithumbSocket = () => {\n  const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n  client.binaryType = \"arraybuffer\";\n  return client;\n}; // 소켓 연결용\n\n\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n  //console.log(type);\n  return eventChannel(emit => {\n    socket.onopen = () => {\n      //if (type === \"CONNECT_UPBIT_SOCKET\") {\n      socket.send(JSON.stringify([{\n        ticket: \"coinbread-clone\"\n      }, {\n        type: connectType,\n        codes: action.payload\n      }])); //} \n\n      /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n          socket.send(\n              JSON.stringify(\n                  { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n              )\n          );\n      }*/\n    };\n\n    socket.onmessage = evt => {\n      //upbit\n      console.log(\"upbit\", evt); //if (type === \"CONNECT_UPBIT_SOCKET\") {\n\n      const enc = new encoding.TextDecoder(\"utf-8\");\n      const data = JSON.parse(enc.decode(evt.data));\n      emit(data); //} \n\n      /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n          emit(JSON.parse(evt.data));\n      }*/\n    };\n\n    socket.onerror = evt => {\n      emit(evt);\n      emit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.close();\n    };\n\n    return unsubscribe;\n  }, buffer || buffers.none());\n};\n\nconst bitconnectSocekt = (socket, connectType, type, action, buffer) => {\n  //console.log(type);\n  return eventChannel(eemit => {\n    socket.onopen = () => {\n      socket.send(JSON.stringify({\n        type: connectType,\n        symbols: action.payload,\n        tickTypes: [\"MID\"]\n      }));\n    };\n\n    socket.onmessage = evt => {\n      console.log(evt.data);\n      eemit(JSON.parse(evt.data));\n    };\n\n    socket.onerror = evt => {\n      eemit(evt);\n      eemit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.close();\n    };\n\n    return unsubscribe;\n  }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  return function* (action = {}) {\n    var client;\n    var clientChannel; //✅ new\n\n    var bitclientChannel; //if (type === \"CONNECT_UPBIT_SOCKET\")\n\n    client = yield call(createUpbitSocket); //else if (type === \"CONNECT_BITHUMB_SOCKET\")\n\n    bitclient = yield call(createBithumbSocket);\n    /*\n            clientChannel = yield call(\n                connectSocekt,\n                client,\n                connectType,\n                type,\n                action,\n                buffers.expanding(500)\n            );*/\n    //✅ new\n\n    bitclientChannel = yield call(bitconnectSocekt, bitclient, connectType, type, action, buffers.expanding(500));\n\n    try {\n      while (true) {\n        //const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n        const bitdatas = yield flush(bitclientChannel);\n        const state = yield select();\n        /*\n                        if (datas.length) {\n                            var sortedObj = {};\n                            datas.forEach((data) => {\n                                if (sortedObj[data.code]) {\n                                    // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                    sortedObj[data.code] =\n                                        sortedObj[data.code].timestamp > data.timestamp\n                                            ? sortedObj[data.code]\n                                            : data;\n                                } else {\n                                    sortedObj[data.code] = data;\n                                }\n                                sortedObj[data.code] = data;\n                            });\n                            const sortedData = Object.keys(sortedObj).map(\n                                (data) => sortedObj[data]\n                            );\n                            yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n                        }*/\n\n        if (bitdatas.length) {\n          /*\n                              var sortedObj = {};\n                              bitdatas.forEach((data) => {\n                                  console.log(data);\n                                  if (sortedObj[data.content]) {\n                                      sortedObj[data.content] =\n                                          sortedObj[data.content].time > data.time\n                                              ? sortedObj[data.content]\n                                              : data;\n                                  } else {\n                                      sortedObj[data.content] = data;\n                                  }\n                                  sortedObj[data.content] = data;\n                                  const sortedData = Object.keys(sortedObj).map(\n                                      (data) => sortedObj[data]\n                                  );\n                                  //coinReadDataUtils(sortedData, state);\n                              });*/\n          console.log(bitdatas);\n        }\n\n        yield delay(500); // 500ms 동안 대기\n      }\n    } catch (e) {\n      yield put({\n        type: ERROR,\n        payload: e\n      });\n    } finally {\n      clientChannel.close();\n    }\n  };\n};\n\nconst bitcreateConnectSocketSaga = (type, connectType, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`; //console.log(\"11\");\n\n  return function* (action = {}) {\n    console.log(\"afsdf\");\n    /*var client;\n    var clientChannel;\n    if (type === \"CONNECT_UPBIT_SOCKET\")\n        client = yield call(createUpbitSocket);\n    else if (type === \"CONNECT_BITHUMB_SOCKET\")\n        client = yield call(createBithumbSocket);\n     clientChannel = yield call(\n        bitconnectSocekt,\n        client,\n        connectType,\n        type,\n        action,\n        buffers.expanding(500)\n    );\n     try {\n        while (true) {\n            const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n            const state = yield select();\n             if (datas.length) {\n                const sortedObj = {};\n                datas.forEach((data) => {\n                    if (type === \"CONNECT_UPBIT_SOCKET\") {\n                        if (sortedObj[data.code]) {\n                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                            sortedObj[data.code] =\n                                sortedObj[data.code].timestamp > data.timestamp\n                                    ? sortedObj[data.code]\n                                    : data;\n                        } else {\n                            sortedObj[data.code] = data;\n                        }\n                        sortedObj[data.code] = data;\n                    }\n                    else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                        console.log(\"check\");\n                        if (sortedObj[data.content]) {\n                            sortedObj[data.content] =\n                                sortedObj[data.content].time > data.time\n                                    ? sortedObj[data.content]\n                                    : data;\n                        } else {\n                            sortedObj[data.content] = data;\n                        }\n                        sortedObj[data.content] = data;\n                    }\n                });\n                 const sortedData = Object.keys(sortedObj).map(\n                    (data) => sortedObj[data]\n                );\n                 yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n            }\n             yield delay(500); // 500ms 동안 대기\n        }\n    } catch (e) {\n        yield put({ type: ERROR, payload: e });\n    } finally {\n        clientChannel.close();\n    }*/\n    //};\n  };\n};\n\nconst connectBithumbSocketThunk = (type, connectType, dataMaker) => {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  const throttleDispatch = throttle((dispatch, state, data) => {\n    dispatch({\n      type: SUCCESS,\n      payload: dataMaker(data, state)\n    });\n  }, 500);\n  return (action = {}) => (dispatch, getState) => {\n    const clientt = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n    clientt.binaryType = \"arraybuffer\";\n    console.log(\"645\");\n\n    clientt.onopen = () => {\n      clientt.send(JSON.stringify({\n        type: connectType,\n        symbols: action.payload,\n        tickTypes: [\"MID\"]\n      }));\n    };\n\n    clientt.onmessage = evt => {\n      /*const enc = new encoding.TextDecoder(\"utf-8\");\n      const arr = new Uint8Array(evt.data);\n      const data = JSON.parse(enc.decode(arr));\n      const state = getState();*/\n      console.log(evt); // dispatch({ type: SUCCESS, payload: dataMaker(data, state) });\n      //throttleDispatch(dispatch, state, data);\n    };\n\n    clientt.onerror = e => {\n      dispatch({\n        type: ERROR,\n        payload: e\n      });\n    };\n  };\n};\n\nexport { createRequestSaga, requestActions, createConnectSocketSaga, createInitRequestSaga, connectBithumbSocketThunk, bitcreateConnectSocketSaga };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/asyncUtil.js"],"names":["call","put","select","flush","delay","w3cwebsocket","W3CWebSocket","buffers","eventChannel","END","encoding","bithumbcoinApi","throttle","compose","coinReadDataUtils","createRequestSaga","type","api","dataMaker","SUCCESS","ERROR","action","res","payload","state","data","e","createInitRequestSaga","requestActions","key","reducerUtils","success","error","createUpbitSocket","client","binaryType","createBithumbSocket","connectSocekt","socket","connectType","buffer","emit","onopen","send","JSON","stringify","ticket","codes","onmessage","evt","console","log","enc","TextDecoder","parse","decode","onerror","unsubscribe","close","none","bitconnectSocekt","eemit","symbols","tickTypes","createConnectSocketSaga","clientChannel","bitclientChannel","bitclient","expanding","bitdatas","length","bitcreateConnectSocketSaga","connectBithumbSocketThunk","throttleDispatch","dispatch","getState","clientt"],"mappings":"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","sourcesContent":["import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\nimport { bithumbcoinApi } from \"../Api/api\";\nimport { throttle } from \"lodash\";\nimport { compose } from \"redux\";\nimport { coinReadDataUtils } from \"./utils\";\nconst createRequestSaga = (type, api, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        /*var res;\n        var ress;\n        if (type === \"GET_BITHUMB_MARKET_NAMES\") {\n            res = yield call(bithumbcoinApi.getKRWMarketCodes);\n            ress = yield call(bithumbcoinApi.getBTCMarketCodes);\n        }*/\n\n        //✅ 업비트\n        const res = yield call(api, action.payload);\n\n\n\n        try {\n            const state = yield select();\n            if (type === \"GET_UPBIT_MARKET_NAMES\")\n                yield put({ type: SUCCESS, payload: dataMaker(res.data, state) });\n            else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\")\n                yield put({ type: SUCCESS, payload: dataMaker(res.data.data, state) });\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        try {\n            const state = yield select();\n            yield put({ type: SUCCESS, payload: dataMaker(action.payload, state) });\n\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\n// requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\nconst requestActions = (type, key) => {\n    const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n\n    return (state, action) => {\n        //console.log(state, action);\n        switch (action.type) {\n            case SUCCESS:\n                //console.log(15);\n                return reducerUtils.success(state, action.payload, key);\n            case ERROR:\n                return reducerUtils.error(state, action.payload, key);\n            default:\n                return state;\n        }\n    };\n};\n\nconst reducerUtils = {\n    success: (state, payload, key) => {\n        return {\n            ...state,\n            [key]: {\n                data: payload,\n                error: false,\n            },\n        };\n    },\n    error: (state, error, key) => ({\n        ...state,\n        [key]: {\n            ...state[key],\n            error: error,\n        },\n    }),\n};\n\nconst createUpbitSocket = () => {\n    const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\nconst createBithumbSocket = () => {\n    const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\n\n\n// 소켓 연결용\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(type);\n    return eventChannel((emit) => {\n        socket.onopen = () => {\n            //if (type === \"CONNECT_UPBIT_SOCKET\") {\n            socket.send(\n                JSON.stringify([\n                    { ticket: \"coinbread-clone\" },\n                    { type: connectType, codes: action.payload },\n                ])\n            );\n            //} \n            /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                socket.send(\n                    JSON.stringify(\n                        { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n                    )\n                );\n            }*/\n        };\n        socket.onmessage = (evt) => {\n            //upbit\n            console.log(\"upbit\", evt);\n            //if (type === \"CONNECT_UPBIT_SOCKET\") {\n            const enc = new encoding.TextDecoder(\"utf-8\");\n            const data = JSON.parse(enc.decode(evt.data));\n            emit(data);\n            //} \n            /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                emit(JSON.parse(evt.data));\n            }*/\n        };\n\n        socket.onerror = (evt) => {\n            emit(evt);\n            emit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst bitconnectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(type);\n    return eventChannel((eemit) => {\n        socket.onopen = () => {\n            socket.send(\n                JSON.stringify(\n                    { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n                )\n            );\n        };\n        socket.onmessage = (evt) => {\n            console.log(evt.data);\n            eemit(JSON.parse(evt.data));\n        };\n\n        socket.onerror = (evt) => {\n            eemit(evt);\n            eemit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n\n        var client;\n        var clientChannel;\n        //✅ new\n        var bitclientChannel;\n\n        //if (type === \"CONNECT_UPBIT_SOCKET\")\n        client = yield call(createUpbitSocket);\n        //else if (type === \"CONNECT_BITHUMB_SOCKET\")\n        bitclient = yield call(createBithumbSocket);\n        /*\n                clientChannel = yield call(\n                    connectSocekt,\n                    client,\n                    connectType,\n                    type,\n                    action,\n                    buffers.expanding(500)\n                );*/\n\n        //✅ new\n        bitclientChannel = yield call(\n            bitconnectSocekt,\n            bitclient,\n            connectType,\n            type,\n            action,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                //const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const bitdatas = yield flush(bitclientChannel);\n\n                const state = yield select();\n                /*\n                                if (datas.length) {\n                                    var sortedObj = {};\n                                    datas.forEach((data) => {\n                                        if (sortedObj[data.code]) {\n                                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                            sortedObj[data.code] =\n                                                sortedObj[data.code].timestamp > data.timestamp\n                                                    ? sortedObj[data.code]\n                                                    : data;\n                                        } else {\n                                            sortedObj[data.code] = data;\n                                        }\n                                        sortedObj[data.code] = data;\n                                    });\n                                    const sortedData = Object.keys(sortedObj).map(\n                                        (data) => sortedObj[data]\n                                    );\n                                    yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n                                }*/\n                if (bitdatas.length) {\n                    /*\n                                        var sortedObj = {};\n                                        bitdatas.forEach((data) => {\n                                            console.log(data);\n                                            if (sortedObj[data.content]) {\n                                                sortedObj[data.content] =\n                                                    sortedObj[data.content].time > data.time\n                                                        ? sortedObj[data.content]\n                                                        : data;\n                                            } else {\n                                                sortedObj[data.content] = data;\n                                            }\n                                            sortedObj[data.content] = data;\n                                            const sortedData = Object.keys(sortedObj).map(\n                                                (data) => sortedObj[data]\n                                            );\n                                            //coinReadDataUtils(sortedData, state);\n                                        });*/\n                    console.log(bitdatas);\n                }\n\n\n\n\n                yield delay(500); // 500ms 동안 대기\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }\n    };\n};\n\n\nconst bitcreateConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n    //console.log(\"11\");\n\n    return function* (action = {}) {\n\n        console.log(\"afsdf\");\n        /*var client;\n        var clientChannel;\n        if (type === \"CONNECT_UPBIT_SOCKET\")\n            client = yield call(createUpbitSocket);\n        else if (type === \"CONNECT_BITHUMB_SOCKET\")\n            client = yield call(createBithumbSocket);\n\n        clientChannel = yield call(\n            bitconnectSocekt,\n            client,\n            connectType,\n            type,\n            action,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const state = yield select();\n\n                if (datas.length) {\n                    const sortedObj = {};\n                    datas.forEach((data) => {\n                        if (type === \"CONNECT_UPBIT_SOCKET\") {\n                            if (sortedObj[data.code]) {\n                                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                sortedObj[data.code] =\n                                    sortedObj[data.code].timestamp > data.timestamp\n                                        ? sortedObj[data.code]\n                                        : data;\n                            } else {\n                                sortedObj[data.code] = data;\n                            }\n                            sortedObj[data.code] = data;\n                        }\n                        else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                            console.log(\"check\");\n                            if (sortedObj[data.content]) {\n                                sortedObj[data.content] =\n                                    sortedObj[data.content].time > data.time\n                                        ? sortedObj[data.content]\n                                        : data;\n                            } else {\n                                sortedObj[data.content] = data;\n                            }\n                            sortedObj[data.content] = data;\n                        }\n                    });\n\n                    const sortedData = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n\n                    yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n                }\n\n                yield delay(500); // 500ms 동안 대기\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }*/\n        //};\n    }\n};\n\n\nconst connectBithumbSocketThunk = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    const throttleDispatch = throttle((dispatch, state, data) => {\n        dispatch({ type: SUCCESS, payload: dataMaker(data, state) });\n    }, 500);\n\n    return (action = {}) => (dispatch, getState) => {\n        const clientt = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n        clientt.binaryType = \"arraybuffer\";\n        console.log(\"645\");\n        clientt.onopen = () => {\n            clientt.send(JSON.stringify(\n                { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n            ));\n        };\n\n        clientt.onmessage = (evt) => {\n            /*const enc = new encoding.TextDecoder(\"utf-8\");\n            const arr = new Uint8Array(evt.data);\n            const data = JSON.parse(enc.decode(arr));\n            const state = getState();*/\n            console.log(evt);\n            // dispatch({ type: SUCCESS, payload: dataMaker(data, state) });\n            //throttleDispatch(dispatch, state, data);\n\n        };\n\n        clientt.onerror = (e) => {\n            dispatch({ type: ERROR, payload: e });\n        };\n    };\n};\n\n\nexport {\n    createRequestSaga,\n    requestActions,\n    createConnectSocketSaga,\n    createInitRequestSaga,\n    connectBithumbSocketThunk,\n    bitcreateConnectSocketSaga\n}"]},"metadata":{},"sourceType":"module"}