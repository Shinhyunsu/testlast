{"ast":null,"code":"import CoinMarketData from \"../Api/CoinMarketData.json\";\nconst coinListDataUtils = {\n  /* marketNames: (names) => {\n       const data = {};\n       names.forEach(name => {\n           let shortSym = name.market.split(\"-\")[1];\n           let moneySym = name.market.split(\"-\")[0];\n           if (moneySym === \"KRW\") {\n               data[shortSym] = {\n                   ...data[shortSym],\n                   upbitSym: name.market\n               }\n           } else if (moneySym === \"USDT\") {\n               data[shortSym] = {\n                   ...data[shortSym],\n                   upbitUSDT: name.market\n               }\n           } else if (moneySym === \"BTC\") {\n               data[shortSym] = {\n                   ...data[shortSym],\n                   upbitBTC: name.market\n               }\n           }\n       });\n       return data;\n   },*/\n  upbitAllNames: names => {\n    const data = {};\n    names.forEach(name => {\n      data[name.market] = {\n        korean: name.korean_name,\n        english: name.english_name\n      };\n    });\n    return data;\n  },\n  upbitPriceNames: (names, state) => {\n    const coinStateDatas = state.Coin.upbitTotalNames.data;\n    names.forEach(name => {\n      let nowPrice = parseFloat(name.trade_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      coinStateDatas[name.market] = {\n        korean: nowPrice\n      };\n    });\n    return coinStateDatas;\n  },\n  binanceNames: names => {\n    const data = {};\n    names.forEach(name => {\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      }\n    }); //console.log(data);\n\n    return data;\n  },\n  bithumbKRWNames: names => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      let nowPrice = parseFloat(names[name].closing_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      data[name + \"_KRW\"] = {\n        korean: nowPrice\n      };\n    });\n    return data;\n  },\n  bithumbBTCNames: (names, state) => {\n    const coinStateDatas = state.Coin.bithumbTotalNames.data;\n    Object.keys(names).forEach(name => {\n      let nowPrice = parseFloat(names[name].closing_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      coinStateDatas[name + \"_BTC\"] = {\n        korean: nowPrice\n      };\n    });\n    return coinStateDatas;\n  }\n};\nconst coinReadDataUtils = {\n  upbitUpdates: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data; //console.log(\"name\", names);\n\n    names.forEach(name => {\n      let shortSym = name.code.split(\"-\")[1];\n      let moneySym = name.code.split(\"-\")[0];\n      let nowPrice = parseFloat(name.trade_price);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitPrice: nowPrice\n        }; //return coinStateDatas;\n      } else if (moneySym === \"USDT\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitUSDTPrice: nowPrice\n        }; //return coinStateDatas;\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitBTCPrice: nowPrice\n        };\n      }\n    });\n    return coinStateDatas;\n  },\n  getUpbitAllMarketNameSagabithumbUpdates: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    names.forEach(name => {\n      let shortSym = name.symbol.split(\"_\")[0];\n      let moneySym = name.symbol.split(\"_\")[1];\n      let nowPrice = name.closePrice;\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: nowPrice\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: nowPrice\n        };\n      }\n    });\n    return coinStateDatas;\n  },\n  //✅\n  mixExchangeUpdates: (one_names, two_names, three_names, gecko_data, state) => {\n    const coinStateDatas = state.Coin.marketNames.data; //✅ bithumb\n\n    two_names.forEach(name => {\n      let shortSym = name.symbol.split(\"_\")[0];\n      let moneySym = name.symbol.split(\"_\")[1];\n      let nowPrice = name.closePrice;\n      var sortOrder = [];\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (coinStateDatas[shortSym]) {\n        Object.keys(coinStateDatas[shortSym]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === \"KRW\") {\n        if (sortOrder[0] === 'upbitSym') {\n          var calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: nowPrice,\n          bithumbKRW_start_per: calper\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: nowPrice\n        };\n      }\n    }); //✅ upbit\n\n    one_names.forEach(name => {\n      let shortSym = name.code.split(\"-\")[1];\n      let moneySym = name.code.split(\"-\")[0];\n      let nowPrice = name.trade_price;\n      var sortOrder = [];\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitPrice: nowPrice\n        };\n      } else if (moneySym === \"USDT\") {\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n        if (coinStateDatas[shortSym]) {\n          Object.keys(coinStateDatas[shortSym]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[0]) {\n            sortOrder.splice(0, 1);\n          } else if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        if (sortOrder[0] === 'upbitSym') {\n          var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitUSDT') {\n          var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[1] === 'upbitBTC') {\n          var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else {\n          var calper = \"Prepare\";\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitUSDTPrice: nowPrice,\n          upbitUSDT_start_per: calper,\n          calKoupbitUSDT: cal\n        };\n      } else if (moneySym === \"BTC\") {\n        var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n        var cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n        if (coinStateDatas[shortSym]) {\n          Object.keys(coinStateDatas[shortSym]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[0] && !sortOrder[1]) {\n            sortOrder.splice(0, 2);\n          } else if (!sortOrder[0]) {\n            sortOrder.splice(0, 1);\n          } else if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        if (sortOrder[0] === 'upbitBTC') {\n          var calper = 'prepare'; //\n        } else if (sortOrder[0] === 'upbitSym') {\n          var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitBTCPrice: nowPrice,\n          //!\n          calKoupbitBTC: cal,\n          upbitBTC_start_per: calper\n        };\n      }\n\n      if (coinStateDatas['BTC'].upbitPrice) {\n        //@\n        var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n        coinStateDatas['USDT'] = { ...coinStateDatas['USDT'],\n          upbitUSDT: 'USDTKRW',\n          upbitUSDTPrice: upbitusdtkrw\n        };\n      }\n    }); //✅ binance\n\n    three_names.forEach(name => {\n      let nowPrice = name.price;\n\n      if (name.symbol === 'MBLBTC' || name.symbol === 'TUSDBTC' || name.symbol === 'DAIBTC' || name.symbol === 'REPBUSD' || name.symbol === 'STORJBUSD' || name.symbol === 'DENTBTC' || name.symbol === 'MFTBTC' || name.symbol === 'SUNBTC' || name.symbol === 'BTTBTC') {\n        return coinStateDatas;\n      }\n\n      if (typeof nowPrice === 'string') nowPrice = parseFloat(nowPrice);\n\n      if (nowPrice < 1.0) {\n        nowPrice = nowPrice.toFixed(8);\n      } else {\n        nowPrice = nowPrice.toFixed(1);\n      }\n\n      var sortOrder = [];\n\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        var len = name.symbol.indexOf('BTC');\n        var coin = name.symbol.slice(0, len);\n        var cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1);\n\n        if (coinStateDatas[coin]) {\n          Object.keys(coinStateDatas[coin]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[0] && !sortOrder[1]) {\n            sortOrder.splice(0, 2);\n          } else if (!sortOrder[0]) {\n            sortOrder.splice(0, 1);\n          } else if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        var calper;\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === \"upbitUSDT\") {\n          //calper = \"prepare\";\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBTCSym: name.symbol,\n            binanBTCPrice: nowPrice,\n            calKobinanBTC: cal,\n            binBTC_start_per: calper\n          };\n        }\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        var len = name.symbol.indexOf('USDT');\n        var coin = name.symbol.slice(0, len);\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        var calper;\n\n        if (coinStateDatas[coin]) {\n          Object.keys(coinStateDatas[coin]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[0] && !sortOrder[1]) {\n            sortOrder.splice(0, 2);\n          } else if (!sortOrder[0]) {\n            sortOrder.splice(0, 1);\n          } else if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === \"upbitUSDT\") {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanUSDTSym: name.symbol,\n            binanUSDTPrice: nowPrice,\n            calKoUSDT: cal,\n            //(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n            binUSDT_start_per: calper\n          };\n        }\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        var len = name.symbol.indexOf('BUSD');\n        var coin = name.symbol.slice(0, len);\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        var calper;\n\n        if (coinStateDatas[coin]) {\n          Object.keys(coinStateDatas[coin]).filter(list => {\n            if (list === 'upbitSym') {\n              sortOrder[0] = 'upbitSym';\n              return sortOrder;\n            } else if (list === 'upbitUSDT') {\n              sortOrder[1] = 'upbitUSDT';\n              return sortOrder;\n            } else if (list === 'upbitBTC') {\n              sortOrder[2] = 'upbitBTC';\n              return sortOrder;\n            }\n          });\n\n          if (!sortOrder[0] && !sortOrder[1]) {\n            sortOrder.splice(0, 2);\n          } else if (!sortOrder[0]) {\n            sortOrder.splice(0, 1);\n          } else if (!sortOrder[1]) {\n            sortOrder.splice(1, 1);\n          }\n        }\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === \"upbitUSDT\") {\n          calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBNBSym: name.symbol,\n            binanBNBPrice: nowPrice,\n            calKoBUSD: cal,\n            //(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n            binBUSD_start_per: calper //calKoUSDT: (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n          };\n        }\n      }\n\n      if (name.symbol === 'BTCBUSD') {\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanBNBSym: name.symbol,\n          binanBNBPrice: nowPrice\n        };\n      } else if (name.symbol === 'BTCUSDT') {\n        var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanUSDTSym: name.symbol,\n          binanUSDTPrice: nowPrice,\n          calKoUSDT: cal,\n          per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n        };\n      }\n    }); //✅ Max per search\n\n    Object.keys(coinStateDatas).forEach(coin => {\n      var read = coinStateDatas[coin];\n      var keyread = Object.keys(read); // bithumbKRW_start_per\n      // binBUSD_start_per\n      // upbitBTC_start_per\n      // upbitUSDT_start_per\n      // BTCper\n      // binUSDT_start_per\n\n      var maxPer = 0.0;\n      var minPer = 0.0;\n      keyread.forEach(name => {\n        var per;\n\n        if (name === 'bithumbKRW_start_per') {\n          per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n        } else if (name === 'binBUSD_start_per') {\n          per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n        } else if (name === 'upbitBTC_start_per') {\n          per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n        } else if (name === 'upbitUSDT_start_per') {\n          per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n        } else if (name === 'BTCper') {\n          per = parseFloat(coinStateDatas[coin].BTCper);\n        } else if (name === 'binUSDT_start_per') {\n          per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n        } else if (name === 'binBTC_start_per') {\n          per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n        }\n\n        if (per > maxPer) {\n          maxPer = per;\n        }\n\n        if (per < minPer) {\n          minPer = per;\n        }\n      });\n      coinStateDatas[coin] = { ...coinStateDatas[coin],\n        totalPer: maxPer,\n        totalminPer: minPer\n      };\n    });\n    return coinStateDatas;\n  },\n  //\n  upbitInitNames: (names, state) => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n\n      if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name\n        };\n      } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name\n        };\n      }\n    });\n    var upbitusdtkrw = (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1);\n    data['USDT'] = { ...data['USDT'],\n      upbitUSDTPrice: upbitusdtkrw,\n      upbitUSDT: 'USDTKRW'\n    };\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n      let imgsrc = \"\";\n      CoinMarketData.find(coin => {\n        if (coin.symbol === shortSym) {\n          imgsrc = coin.imgsrc;\n        }\n      });\n\n      if (moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name,\n          imgsrc: imgsrc\n        };\n      } else if (moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name,\n          imgsrc: imgsrc,\n          calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n        };\n      } else if (moneySym === \"BTC\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitBTCPrice: names[name].korean,\n          upbitBTC: name,\n          imgsrc: imgsrc,\n          calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n        };\n      }\n    });\n    return data;\n  },\n  bithumbInitNames: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"_\")[0];\n      let moneySym = name.split(\"_\")[1];\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: names[name].korean,\n          bithumbSym: name\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: names[name].korean,\n          bithumbBTC: name,\n          calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n        };\n      }\n    });\n    return coinStateDatas;\n  }\n};\nexport { coinListDataUtils, coinReadDataUtils };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/utils.js"],"names":["CoinMarketData","coinListDataUtils","upbitAllNames","names","data","forEach","name","market","korean","korean_name","english","english_name","upbitPriceNames","state","coinStateDatas","Coin","upbitTotalNames","nowPrice","parseFloat","trade_price","toFixed","binanceNames","symbol","lastIndexOf","price","bithumbKRWNames","Object","keys","closing_price","bithumbBTCNames","bithumbTotalNames","coinReadDataUtils","upbitUpdates","marketNames","shortSym","code","split","moneySym","upbitPrice","upbitUSDTPrice","upbitBTCPrice","getUpbitAllMarketNameSagabithumbUpdates","closePrice","bithumbPrice","bithumbBTCPrice","mixExchangeUpdates","one_names","two_names","three_names","gecko_data","sortOrder","filter","list","splice","calper","bithumbKRW_start_per","cal","calKoupbitBTC","upbitUSDT_start_per","calKoupbitUSDT","origin","upbitBTC_start_per","upbitusdtkrw","upbitUSDT","len","indexOf","coin","slice","binanBTCSym","binanBTCPrice","calKobinanBTC","binBTC_start_per","binanUSDTSym","binanUSDTPrice","calKoUSDT","binUSDT_start_per","binanBNBSym","binanBNBPrice","calKoBUSD","binBUSD_start_per","per","read","keyread","maxPer","minPer","BTCper","totalPer","totalminPer","upbitInitNames","upbitSym","imgsrc","find","upbitBTC","bithumbInitNames","bithumbSym","bithumbBTC","calKobithumbBTC"],"mappings":"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","sourcesContent":["import CoinMarketData from \"../Api/CoinMarketData.json\";\n\n\n\n\nconst coinListDataUtils = {\n    /* marketNames: (names) => {\n         const data = {};\n         names.forEach(name => {\n             let shortSym = name.market.split(\"-\")[1];\n             let moneySym = name.market.split(\"-\")[0];\n             if (moneySym === \"KRW\") {\n                 data[shortSym] = {\n                     ...data[shortSym],\n                     upbitSym: name.market\n                 }\n             } else if (moneySym === \"USDT\") {\n                 data[shortSym] = {\n                     ...data[shortSym],\n                     upbitUSDT: name.market\n                 }\n             } else if (moneySym === \"BTC\") {\n                 data[shortSym] = {\n                     ...data[shortSym],\n                     upbitBTC: name.market\n                 }\n             }\n         });\n         return data;\n     },*/\n    upbitAllNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            data[name.market] = {\n                korean: name.korean_name,\n                english: name.english_name,\n            };\n        })\n        return data;\n    },\n    upbitPriceNames: (names, state) => {\n        const coinStateDatas = state.Coin.upbitTotalNames.data;\n        names.forEach(name => {\n            let nowPrice = parseFloat(name.trade_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            coinStateDatas[name.market] = {\n                korean: nowPrice,\n            };\n        })\n        return coinStateDatas;\n    },\n\n    binanceNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            }\n\n        })\n        //console.log(data);\n        return data;\n    },\n    bithumbKRWNames: (names) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let nowPrice = parseFloat(names[name].closing_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            data[name + \"_KRW\"] = {\n                korean: nowPrice,\n            };\n        })\n\n        return data;\n    },\n    bithumbBTCNames: (names, state) => {\n        const coinStateDatas = state.Coin.bithumbTotalNames.data;\n\n        Object.keys(names).forEach(name => {\n            let nowPrice = parseFloat(names[name].closing_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            coinStateDatas[name + \"_BTC\"] = {\n                korean: nowPrice,\n            };\n        })\n        return coinStateDatas;\n    }\n};\n\nconst coinReadDataUtils = {\n    upbitUpdates: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //console.log(\"name\", names);\n        names.forEach(name => {\n\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = parseFloat(name.trade_price);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n                //return coinStateDatas;\n            } else if (moneySym === \"USDT\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice\n                }\n                //return coinStateDatas;\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice\n                }\n            }\n        });\n        return coinStateDatas;\n    },\n    getUpbitAllMarketNameSagabithumbUpdates: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        names.forEach(name => {\n\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = name.closePrice;\n\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            } else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice\n                }\n            }\n        });\n        return coinStateDatas;\n    },\n    //✅\n    mixExchangeUpdates: (one_names, two_names, three_names, gecko_data, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //✅ bithumb\n        two_names.forEach(name => {\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = name.closePrice;\n            var sortOrder = [];\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === \"KRW\") {\n                if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2)\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice,\n                    bithumbKRW_start_per: calper\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice\n                }\n            }\n        });\n        //✅ upbit\n        one_names.forEach(name => {\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = name.trade_price;\n            var sortOrder = [];\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n            } else if (moneySym === \"USDT\") {\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (coinStateDatas[shortSym]) {\n                    Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitUSDT') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[1] === 'upbitBTC') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else {\n                    var calper = \"Prepare\";\n                }\n\n\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice,\n\n                    upbitUSDT_start_per: calper,\n                    calKoupbitUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n                var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n                var cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n\n                if (coinStateDatas[shortSym]) {\n                    Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    var calper = 'prepare';\n                    //\n                } else if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n                }\n\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice,\n                    //!\n                    calKoupbitBTC: cal,\n                    upbitBTC_start_per: calper\n                }\n            }\n\n            if (coinStateDatas['BTC'].upbitPrice) {\n                //@\n                var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n\n                coinStateDatas['USDT'] = {\n                    ...coinStateDatas['USDT'],\n\n                    upbitUSDT: 'USDTKRW',\n                    upbitUSDTPrice: upbitusdtkrw\n                }\n            }\n        });\n\n\n        //✅ binance\n        three_names.forEach(name => {\n            let nowPrice = name.price;\n\n            if (name.symbol === 'MBLBTC' || name.symbol === 'TUSDBTC' || name.symbol === 'DAIBTC' || name.symbol === 'REPBUSD' || name.symbol === 'STORJBUSD' || name.symbol === 'DENTBTC' || name.symbol === 'MFTBTC' || name.symbol === 'SUNBTC' || name.symbol === 'BTTBTC') {\n                return coinStateDatas;\n            }\n\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            var sortOrder = [];\n\n\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                var len = name.symbol.indexOf('BTC');\n                var coin = name.symbol.slice(0, len);\n                var cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n                var calper;\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    //calper = \"prepare\";\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBTCSym: name.symbol,\n                        binanBTCPrice: nowPrice,\n                        calKobinanBTC: cal,\n                        binBTC_start_per: calper\n                    }\n                }\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                var len = name.symbol.indexOf('USDT');\n\n                var coin = name.symbol.slice(0, len);\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                var calper;\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanUSDTSym: name.symbol,\n                        binanUSDTPrice: nowPrice,\n                        calKoUSDT: cal,//(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                        binUSDT_start_per: calper,\n                    }\n                }\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                var len = name.symbol.indexOf('BUSD');\n                var coin = name.symbol.slice(0, len);\n\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                var calper;\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBNBSym: name.symbol,\n                        binanBNBPrice: nowPrice,\n                        calKoBUSD: cal,//(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                        binBUSD_start_per: calper,\n                        //calKoUSDT: (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                    }\n                }\n            }\n\n            if (name.symbol === 'BTCBUSD') {\n\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanBNBSym: name.symbol,\n                    binanBNBPrice: nowPrice\n\n                }\n            } else if (name.symbol === 'BTCUSDT') {\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanUSDTSym: name.symbol,\n                    binanUSDTPrice: nowPrice,\n                    calKoUSDT: cal,\n                    per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n                }\n            }\n        });\n\n        //✅ Max per search\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n\n            // bithumbKRW_start_per\n            // binBUSD_start_per\n            // upbitBTC_start_per\n            // upbitUSDT_start_per\n            // BTCper\n            // binUSDT_start_per\n\n            var maxPer = 0.0;\n            var minPer = 0.0;\n            keyread.forEach((name) => {\n                var per;\n                if (name === 'bithumbKRW_start_per') {\n                    per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n                }\n                else if (name === 'binBUSD_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n                } else if (name === 'upbitBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n                } else if (name === 'upbitUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n                } else if (name === 'BTCper') {\n                    per = parseFloat(coinStateDatas[coin].BTCper);\n                } else if (name === 'binUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n                }\n                else if (name === 'binBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n                }\n                if (per > maxPer) {\n                    maxPer = per;\n                }\n                if (per < minPer) {\n                    minPer = per;\n                }\n            })\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                totalPer: maxPer,\n                totalminPer: minPer\n            }\n        });\n        return coinStateDatas;\n    },\n    //\n    upbitInitNames: (names, state) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n\n            if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                }\n            } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                }\n            }\n        })\n\n        var upbitusdtkrw = (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1);\n\n        data['USDT'] = {\n            ...data['USDT'],\n            upbitUSDTPrice: upbitusdtkrw,\n            upbitUSDT: 'USDTKRW',\n        }\n\n        Object.keys(names).forEach(name => {\n\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n            let imgsrc = \"\";\n            CoinMarketData.find((coin) => {\n                if (coin.symbol === shortSym) {\n                    imgsrc = coin.imgsrc;\n                }\n            })\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                    imgsrc: imgsrc\n                }\n            } else if (moneySym === \"USDT\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                    imgsrc: imgsrc,\n                    calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n                }\n            } else if (moneySym === \"BTC\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTCPrice: names[name].korean,\n                    upbitBTC: name,\n                    imgsrc: imgsrc,\n                    calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        });\n        return data;\n    },\n    bithumbInitNames: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"_\")[0];\n            let moneySym = name.split(\"_\")[1];\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: names[name].korean,\n                    bithumbSym: name,\n                }\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: names[name].korean,\n                    bithumbBTC: name,\n                    calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        })\n\n\n        return coinStateDatas;\n    }\n};\n\n\nexport {\n    coinListDataUtils,\n    coinReadDataUtils\n}"]},"metadata":{},"sourceType":"module"}