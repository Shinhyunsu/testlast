{"ast":null,"code":"import CoinMarketData from \"../Api/CoinMarketData.json\";\n\nconst pricereturnFloat = price => {\n  let data = parseFloat(price);\n\n  if (data < 1.0) {\n    return data.toFixed(8);\n  } else {\n    return data.toFixed(1);\n  }\n};\n\nconst coinListDataUtils = {\n  upbitAllNames: names => {\n    const data = {};\n    names.forEach(name => {\n      data[name.market] = {\n        korean: name.korean_name\n      };\n    });\n    return data;\n  },\n  upbitPriceNames: (names, state) => {\n    const coinStateDatas = state.Coin.upbitTotalNames.data;\n    names.forEach(name => {\n      coinStateDatas[name.market] = {\n        korean: pricereturnFloat(name.trade_price)\n      };\n    });\n    return coinStateDatas;\n  },\n  binanceNames: names => {\n    const data = {};\n    names.forEach(name => {\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        data[name.symbol] = {\n          korean: name.price\n        };\n      }\n    });\n    return data;\n  },\n  bithumbKRWNames: names => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      data[name + \"_KRW\"] = {\n        korean: pricereturnFloat(names[name].closing_price)\n      };\n    });\n    return data;\n  },\n  bithumbBTCNames: (names, state) => {\n    const coinStateDatas = state.Coin.bithumbTotalNames.data;\n    Object.keys(names).forEach(name => {\n      coinStateDatas[name + \"_BTC\"] = {\n        korean: pricereturnFloat(names[name].closing_price)\n      };\n    });\n    return coinStateDatas;\n  }\n};\nconst coinReadDataUtils = {\n  mixExchangeUpdates: (one_names, two_names, three_names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data; //✅ bithumb\n\n    two_names.forEach(name => {\n      let shortSym = name.symbol.split(\"_\")[0];\n      let moneySym = name.symbol.split(\"_\")[1];\n      let nowPrice = pricereturnFloat(name.closePrice);\n      var sortOrder = [];\n      var cal, calper;\n\n      if (coinStateDatas[shortSym]) {\n        Object.keys(coinStateDatas[shortSym]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === \"KRW\") {\n        if (sortOrder[0] === 'upbitSym') {\n          calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: nowPrice,\n          bithumbKRW_start_per: calper\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: nowPrice,\n          calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].bithumbPrice) * parseFloat(nowPrice)).toFixed(1)\n        };\n      }\n    }); //✅ upbit\n\n    one_names.forEach(name => {\n      let shortSym = name.code.split(\"-\")[1];\n      let moneySym = name.code.split(\"-\")[0];\n      let nowPrice = pricereturnFloat(name.trade_price);\n      var sortOrder = [];\n      var cal, calper;\n\n      if (coinStateDatas[shortSym]) {\n        Object.keys(coinStateDatas[shortSym]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0] && !sortOrder[1]) {\n          sortOrder.splice(0, 2);\n        } else if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitPrice: nowPrice\n        };\n      } else if (moneySym === \"USDT\") {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n        if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        } else if (sortOrder[0] === 'upbitUSDT') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else if (sortOrder[1] === 'upbitBTC') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2);\n        } else {\n          calper = \"Prepare\";\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitUSDTPrice: nowPrice,\n          upbitUSDT_start_per: calper,\n          calKoupbitUSDT: cal\n        };\n      } else if (moneySym === \"BTC\") {\n        var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n        cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n        if (sortOrder[0] === 'upbitBTC') {\n          calper = 'prepare';\n        } else if (sortOrder[0] === 'upbitSym') {\n          calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n        }\n\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          upbitBTCPrice: nowPrice,\n          //!\n          calKoupbitBTC: cal,\n          upbitBTC_start_per: calper\n        };\n      }\n\n      if (coinStateDatas['BTC'].upbitPrice) {\n        //@\n        var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n        coinStateDatas['USDT'] = { ...coinStateDatas['USDT'],\n          upbitUSDT: 'USDTKRW',\n          upbitUSDTPrice: upbitusdtkrw\n        };\n      }\n    }); //✅ binance\n\n    three_names.forEach(name => {\n      let nowPrice = pricereturnFloat(name.price);\n      var sortOrder = [];\n      var len, cal, calper, coin;\n      let moneySym;\n      if (name.symbol === 'MBLBTC' || name.symbol === 'TUSDBTC' || name.symbol === 'DAIBTC' || name.symbol === 'REPBUSD' || name.symbol === 'STORJBUSD' || name.symbol === 'DENTBTC' || name.symbol === 'MFTBTC' || name.symbol === 'SUNBTC' || name.symbol === 'BTTBTC') return coinStateDatas;\n\n      if (name.symbol.lastIndexOf('BTC') !== -1) {\n        len = name.symbol.indexOf('BTC');\n        moneySym = 'BTC';\n      } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n        len = name.symbol.indexOf('USDT');\n        moneySym = 'USDT';\n      } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n        len = name.symbol.indexOf('BUSD');\n        moneySym = 'BUSD';\n      }\n\n      coin = name.symbol.slice(0, len);\n\n      if (coinStateDatas[coin]) {\n        Object.keys(coinStateDatas[coin]).filter(list => {\n          if (list === 'upbitSym') {\n            sortOrder[0] = 'upbitSym';\n            return sortOrder;\n          } else if (list === 'upbitUSDT') {\n            sortOrder[1] = 'upbitUSDT';\n            return sortOrder;\n          } else if (list === 'upbitBTC') {\n            sortOrder[2] = 'upbitBTC';\n            return sortOrder;\n          }\n        });\n\n        if (!sortOrder[0] && !sortOrder[1]) {\n          sortOrder.splice(0, 2);\n        } else if (!sortOrder[0]) {\n          sortOrder.splice(0, 1);\n        } else if (!sortOrder[1]) {\n          sortOrder.splice(1, 1);\n        }\n      }\n\n      if (moneySym === 'BTC') {\n        cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1);\n        if (sortOrder[0] === 'upbitBTC') calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === \"upbitUSDT\") calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === 'upbitSym') calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBTCSym: name.symbol,\n            binanBTCPrice: nowPrice,\n            calKobinanBTC: cal,\n            binBTC_start_per: calper\n          };\n        }\n      } else if (moneySym === 'USDT') {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        if (sortOrder[0] === 'upbitBTC') calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === \"upbitUSDT\") calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);else if (sortOrder[0] === 'upbitSym') calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanUSDTSym: name.symbol,\n            binanUSDTPrice: nowPrice,\n            calKoUSDT: cal,\n            binUSDT_start_per: calper\n          };\n        }\n      } else if (moneySym === 'BUSD') {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        if (sortOrder[0] === 'upbitBTC') calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2);else if (sortOrder[0] === \"upbitUSDT\") calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2);else if (sortOrder[0] === 'upbitSym') calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2);\n\n        if (coin !== \"\") {\n          coinStateDatas[coin] = { ...coinStateDatas[coin],\n            binanBNBSym: name.symbol,\n            binanBNBPrice: nowPrice,\n            calKoBUSD: cal,\n            binBUSD_start_per: calper\n          };\n        }\n      } //📌 EXCEPTION\n\n\n      if (name.symbol === 'BTCBUSD') {\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanBNBSym: name.symbol,\n          binanBNBPrice: nowPrice\n        };\n      } else if (name.symbol === 'BTCUSDT') {\n        cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n        coinStateDatas['BTC'] = { ...coinStateDatas['BTC'],\n          binanUSDTSym: name.symbol,\n          binanUSDTPrice: nowPrice,\n          calKoUSDT: cal,\n          per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n        };\n      }\n    }); //✅ Max per search\n\n    Object.keys(coinStateDatas).forEach(coin => {\n      var read = coinStateDatas[coin];\n      var keyread = Object.keys(read);\n      var maxPer = 0.0;\n      var minPer = 0.0;\n      keyread.forEach(name => {\n        var per;\n\n        if (name === 'bithumbKRW_start_per') {\n          per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n        } else if (name === 'binBUSD_start_per') {\n          per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n        } else if (name === 'upbitBTC_start_per') {\n          per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n        } else if (name === 'upbitUSDT_start_per') {\n          per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n        } else if (name === 'BTCper') {\n          per = parseFloat(coinStateDatas[coin].BTCper);\n        } else if (name === 'binUSDT_start_per') {\n          per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n        } else if (name === 'binBTC_start_per') {\n          per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n        }\n\n        if (per > maxPer) {\n          maxPer = per;\n        }\n\n        if (per < minPer) {\n          minPer = per;\n        }\n      });\n      coinStateDatas[coin] = { ...coinStateDatas[coin],\n        totalPer: maxPer,\n        totalminPer: minPer\n      };\n    }); //📦 v2\n\n    Object.keys(coinStateDatas).forEach(coin => {\n      var read = coinStateDatas[coin];\n      var keyread = Object.keys(read);\n      var maxPer = 0.0;\n      var minPer = 0.0;\n      keyread.forEach(name => {\n        var price;\n\n        if (name === 'upbitPrice') {\n          price = parseFloat(coinStateDatas[coin].upbitPrice);\n        } else if (name === 'calKoupbitBTC') {\n          price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n        } else if (name === 'calKobithumbBTC') {\n          price = parseFloat(coinStateDatas[coin].calKobithumbBTC);\n        } else if (name === 'calKobinanBTC') {\n          price = parseFloat(coinStateDatas[coin].calKobinanBTC);\n        } else if (name === 'calKoupbitUSDT') {\n          price = parseFloat(coinStateDatas[coin].calKoupbitUSDT);\n        } else if (name === 'calKoUSDT') {\n          price = parseFloat(coinStateDatas[coin].calKoUSDT);\n        } else if (name === 'calKoBUSD') {\n          price = parseFloat(coinStateDatas[coin].calKoBUSD);\n        } else if (name === 'calKoupbitBTC') {\n          price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n        }\n\n        if (price > maxPer) {\n          maxPer = price;\n        }\n\n        if (price < minPer) {\n          minPer = price;\n        }\n      });\n\n      if (coin === 'ETH') {\n        console.log(minPer, maxPer);\n      }\n      /* var result = 0.0;\n       result = (maxPer - minPer) / minPer * 100;\n         coinStateDatas[coin] = {\n           ...coinStateDatas[coin],\n           testper: result\n       }*/\n\n    });\n    return coinStateDatas;\n  },\n  //\n  upbitInitNames: (names, state) => {\n    const data = {};\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n\n      if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name\n        };\n      } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name\n        };\n      }\n    });\n    data['USDT'] = { ...data['USDT'],\n      upbitUSDTPrice: (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1),\n      upbitUSDT: 'USDTKRW'\n    };\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"-\")[1];\n      let moneySym = name.split(\"-\")[0];\n      let imgsrc = \"\";\n      CoinMarketData.find(coin => {\n        if (coin.symbol === shortSym) {\n          imgsrc = coin.imgsrc;\n        }\n      });\n\n      if (moneySym === \"KRW\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitPrice: names[name].korean,\n          upbitSym: name,\n          imgsrc: imgsrc\n        };\n      } else if (moneySym === \"USDT\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitUSDTPrice: names[name].korean,\n          upbitUSDT: name,\n          imgsrc: imgsrc,\n          calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n        };\n      } else if (moneySym === \"BTC\") {\n        data[shortSym] = { ...data[shortSym],\n          upbitBTCPrice: names[name].korean,\n          upbitBTC: name,\n          imgsrc: imgsrc,\n          calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n        };\n      }\n    });\n    return data;\n  },\n  bithumbInitNames: (names, state) => {\n    const coinStateDatas = state.Coin.marketNames.data;\n    Object.keys(names).forEach(name => {\n      let shortSym = name.split(\"_\")[0];\n      let moneySym = name.split(\"_\")[1];\n\n      if (moneySym === \"KRW\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbPrice: names[name].korean,\n          bithumbSym: name\n        };\n      } else if (moneySym === \"BTC\") {\n        coinStateDatas[shortSym] = { ...coinStateDatas[shortSym],\n          bithumbBTCPrice: names[name].korean,\n          bithumbBTC: name,\n          calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n        };\n      }\n    });\n    return coinStateDatas;\n  }\n};\nexport { coinListDataUtils, coinReadDataUtils };","map":{"version":3,"sources":["/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/utils.js"],"names":["CoinMarketData","pricereturnFloat","price","data","parseFloat","toFixed","coinListDataUtils","upbitAllNames","names","forEach","name","market","korean","korean_name","upbitPriceNames","state","coinStateDatas","Coin","upbitTotalNames","trade_price","binanceNames","symbol","lastIndexOf","bithumbKRWNames","Object","keys","closing_price","bithumbBTCNames","bithumbTotalNames","coinReadDataUtils","mixExchangeUpdates","one_names","two_names","three_names","marketNames","shortSym","split","moneySym","nowPrice","closePrice","sortOrder","cal","calper","filter","list","splice","upbitPrice","bithumbPrice","bithumbKRW_start_per","bithumbBTCPrice","calKobithumbBTC","code","upbitUSDTPrice","calKoupbitBTC","upbitUSDT_start_per","calKoupbitUSDT","origin","upbitBTCPrice","upbitBTC_start_per","upbitusdtkrw","upbitUSDT","len","coin","indexOf","slice","binanBTCSym","binanBTCPrice","calKobinanBTC","binBTC_start_per","binanUSDTSym","binanUSDTPrice","calKoUSDT","binUSDT_start_per","binanBNBSym","binanBNBPrice","calKoBUSD","binBUSD_start_per","per","read","keyread","maxPer","minPer","BTCper","totalPer","totalminPer","console","log","upbitInitNames","upbitSym","imgsrc","find","upbitBTC","bithumbInitNames","bithumbSym","bithumbBTC"],"mappings":"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","sourcesContent":["import CoinMarketData from \"../Api/CoinMarketData.json\";\n\nconst pricereturnFloat = (price) => {\n    let data = parseFloat(price);\n    if (data < 1.0) {\n        return data.toFixed(8);\n    }\n    else {\n        return data.toFixed(1);\n    }\n}\n\nconst coinListDataUtils = {\n    upbitAllNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            data[name.market] = {\n                korean: name.korean_name,\n            };\n        })\n        return data;\n    },\n    upbitPriceNames: (names, state) => {\n        const coinStateDatas = state.Coin.upbitTotalNames.data;\n        names.forEach(name => {\n            coinStateDatas[name.market] = {\n                korean: pricereturnFloat(name.trade_price),\n            };\n        })\n        return coinStateDatas;\n    },\n\n    binanceNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            }\n        })\n        return data;\n    },\n    bithumbKRWNames: (names) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            data[name + \"_KRW\"] = {\n                korean: pricereturnFloat(names[name].closing_price),\n            };\n        })\n        return data;\n    },\n    bithumbBTCNames: (names, state) => {\n        const coinStateDatas = state.Coin.bithumbTotalNames.data;\n        Object.keys(names).forEach(name => {\n            coinStateDatas[name + \"_BTC\"] = {\n                korean: pricereturnFloat(names[name].closing_price),\n            };\n        })\n        return coinStateDatas;\n    }\n};\n\nconst coinReadDataUtils = {\n    mixExchangeUpdates: (one_names, two_names, three_names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //✅ bithumb\n        two_names.forEach(name => {\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = pricereturnFloat(name.closePrice);\n            var sortOrder = [];\n            var cal, calper;\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === \"KRW\") {\n                if (sortOrder[0] === 'upbitSym') {\n                    calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2)\n                }\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice,\n                    bithumbKRW_start_per: calper\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice,\n                    calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].bithumbPrice) * parseFloat(nowPrice)).toFixed(1)\n                }\n            }\n        });\n        //✅ upbit\n        one_names.forEach(name => {\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = pricereturnFloat(name.trade_price);\n            var sortOrder = [];\n            var cal, calper;\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0] && !sortOrder[1]) {\n                    sortOrder.splice(0, 2);\n                }\n                else if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n            } else if (moneySym === \"USDT\") {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitUSDT') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[1] === 'upbitBTC') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else {\n                    calper = \"Prepare\";\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice,\n\n                    upbitUSDT_start_per: calper,\n                    calKoupbitUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n                var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n                cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = 'prepare';\n\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice,\n                    //!\n                    calKoupbitBTC: cal,\n                    upbitBTC_start_per: calper\n                }\n            }\n\n            if (coinStateDatas['BTC'].upbitPrice) {\n                //@\n                var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n\n                coinStateDatas['USDT'] = {\n                    ...coinStateDatas['USDT'],\n\n                    upbitUSDT: 'USDTKRW',\n                    upbitUSDTPrice: upbitusdtkrw\n                }\n            }\n        });\n\n\n        //✅ binance\n        three_names.forEach(name => {\n            let nowPrice = pricereturnFloat(name.price);\n            var sortOrder = [];\n            var len, cal, calper, coin;\n            let moneySym;\n\n            if (name.symbol === 'MBLBTC' || name.symbol === 'TUSDBTC' || name.symbol === 'DAIBTC' || name.symbol === 'REPBUSD' || name.symbol === 'STORJBUSD' || name.symbol === 'DENTBTC' || name.symbol === 'MFTBTC' || name.symbol === 'SUNBTC' || name.symbol === 'BTTBTC')\n                return coinStateDatas;\n\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                len = name.symbol.indexOf('BTC');\n                moneySym = 'BTC';\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                len = name.symbol.indexOf('USDT');\n                moneySym = 'USDT';\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                len = name.symbol.indexOf('BUSD');\n                moneySym = 'BUSD';\n            }\n            coin = name.symbol.slice(0, len);\n\n            if (coinStateDatas[coin]) {\n                Object.keys(coinStateDatas[coin]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0] && !sortOrder[1]) {\n                    sortOrder.splice(0, 2);\n                }\n                else if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === 'BTC') {\n                cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBTCSym: name.symbol,\n                        binanBTCPrice: nowPrice,\n                        calKobinanBTC: cal,\n                        binBTC_start_per: calper\n                    }\n                }\n            } else if (moneySym === 'USDT') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanUSDTSym: name.symbol,\n                        binanUSDTPrice: nowPrice,\n                        calKoUSDT: cal,\n                        binUSDT_start_per: calper,\n                    }\n                }\n            } else if (moneySym === 'BUSD') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBNBSym: name.symbol,\n                        binanBNBPrice: nowPrice,\n                        calKoBUSD: cal,\n                        binBUSD_start_per: calper,\n                    }\n                }\n            }\n            //📌 EXCEPTION\n            if (name.symbol === 'BTCBUSD') {\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanBNBSym: name.symbol,\n                    binanBNBPrice: nowPrice\n                }\n            } else if (name.symbol === 'BTCUSDT') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanUSDTSym: name.symbol,\n                    binanUSDTPrice: nowPrice,\n                    calKoUSDT: cal,\n                    per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n                }\n            }\n        });\n\n        //✅ Max per search\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n            var maxPer = 0.0;\n            var minPer = 0.0;\n            keyread.forEach((name) => {\n                var per;\n                if (name === 'bithumbKRW_start_per') {\n                    per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n                }\n                else if (name === 'binBUSD_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n                } else if (name === 'upbitBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n                } else if (name === 'upbitUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n                } else if (name === 'BTCper') {\n                    per = parseFloat(coinStateDatas[coin].BTCper);\n                } else if (name === 'binUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n                }\n                else if (name === 'binBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n                }\n                if (per > maxPer) {\n                    maxPer = per;\n                }\n                if (per < minPer) {\n                    minPer = per;\n                }\n            })\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                totalPer: maxPer,\n                totalminPer: minPer\n            }\n        });\n\n        //📦 v2\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n            var maxPer = 0.0;\n            var minPer = 0.0;\n            keyread.forEach((name) => {\n                var price;\n                if (name === 'upbitPrice') {\n                    price = parseFloat(coinStateDatas[coin].upbitPrice);\n                }\n                else if (name === 'calKoupbitBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n                }\n                else if (name === 'calKobithumbBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKobithumbBTC);\n                } else if (name === 'calKobinanBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKobinanBTC);\n                } else if (name === 'calKoupbitUSDT') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitUSDT);\n                } else if (name === 'calKoUSDT') {\n                    price = parseFloat(coinStateDatas[coin].calKoUSDT);\n                } else if (name === 'calKoBUSD') {\n                    price = parseFloat(coinStateDatas[coin].calKoBUSD);\n                }\n                else if (name === 'calKoupbitBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n                }\n\n                if (price > maxPer) {\n                    maxPer = price;\n                }\n                if (price < minPer) {\n                    minPer = price;\n                }\n            })\n            if (coin === 'ETH') {\n                console.log(minPer, maxPer);\n            }\n            /* var result = 0.0;\n             result = (maxPer - minPer) / minPer * 100;\n \n             coinStateDatas[coin] = {\n                 ...coinStateDatas[coin],\n                 testper: result\n             }*/\n        });\n        return coinStateDatas;\n    },\n    //\n    upbitInitNames: (names, state) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n\n            if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                }\n            } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                }\n            }\n        })\n        data['USDT'] = {\n            ...data['USDT'],\n            upbitUSDTPrice: (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1),\n            upbitUSDT: 'USDTKRW',\n        }\n\n        Object.keys(names).forEach(name => {\n\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n            let imgsrc = \"\";\n            CoinMarketData.find((coin) => {\n                if (coin.symbol === shortSym) {\n                    imgsrc = coin.imgsrc;\n                }\n            })\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                    imgsrc: imgsrc\n                }\n            } else if (moneySym === \"USDT\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                    imgsrc: imgsrc,\n                    calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n                }\n            } else if (moneySym === \"BTC\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTCPrice: names[name].korean,\n                    upbitBTC: name,\n                    imgsrc: imgsrc,\n                    calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        });\n        return data;\n    },\n    bithumbInitNames: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"_\")[0];\n            let moneySym = name.split(\"_\")[1];\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: names[name].korean,\n                    bithumbSym: name,\n                }\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: names[name].korean,\n                    bithumbBTC: name,\n                    calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        })\n\n\n        return coinStateDatas;\n    }\n};\n\n\nexport {\n    coinListDataUtils,\n    coinReadDataUtils\n}"]},"metadata":{},"sourceType":"module"}