[{"/Users/sinhyeonsu/Documents/coingetprice2/src/index.js":"1","/Users/sinhyeonsu/Documents/coingetprice2/src/App.js":"2","/Users/sinhyeonsu/Documents/coingetprice2/src/reportWebVitals.js":"3","/Users/sinhyeonsu/Documents/coingetprice2/src/Reducer/index.js":"4","/Users/sinhyeonsu/Documents/coingetprice2/src/Reducer/coinReducer.js":"5","/Users/sinhyeonsu/Documents/coingetprice2/src/Api/api.js":"6","/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/utils.js":"7","/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/asyncUtil.js":"8","/Users/sinhyeonsu/Documents/coingetprice2/src/container/CoinContainer.js":"9","/Users/sinhyeonsu/Documents/coingetprice2/src/components/CoinList.js":"10","/Users/sinhyeonsu/Documents/coingetprice2/src/Router.js":"11","/Users/sinhyeonsu/Documents/coingetprice2/src/routes/Auth.js":"12","/Users/sinhyeonsu/Documents/coingetprice2/src/routes/Home.js":"13","/Users/sinhyeonsu/Documents/coingetprice2/src/fbase.js":"14","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/index.js":"15","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/App.js":"16","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/reportWebVitals.js":"17","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Reducer/index.js":"18","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Reducer/coinReducer.js":"19","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/container/CoinContainer.js":"20","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Api/api.js":"21","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/asyncUtil.js":"22","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/utils.js":"23","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/components/CoinList.js":"24","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/components/Coinone.js":"25"},{"size":958,"mtime":1634186274843,"results":"26","hashOfConfig":"27"},{"size":2259,"mtime":1635402781251,"results":"28","hashOfConfig":"27"},{"size":362,"mtime":1633866378915,"results":"29","hashOfConfig":"27"},{"size":292,"mtime":1634289166201,"results":"30","hashOfConfig":"27"},{"size":7282,"mtime":1634790357839,"results":"31","hashOfConfig":"27"},{"size":3217,"mtime":1634792201472,"results":"32","hashOfConfig":"27"},{"size":26741,"mtime":1635305248894,"results":"33","hashOfConfig":"27"},{"size":13945,"mtime":1635088902977,"results":"34","hashOfConfig":"27"},{"size":1835,"mtime":1635263441295,"results":"35","hashOfConfig":"27"},{"size":11005,"mtime":1635405150610,"results":"36","hashOfConfig":"27"},{"size":776,"mtime":1635404898233,"results":"37","hashOfConfig":"27"},{"size":1036,"mtime":1635404752408,"results":"38","hashOfConfig":"27"},{"size":118,"mtime":1635404899808,"results":"39","hashOfConfig":"27"},{"size":986,"mtime":1635380908662,"results":"40","hashOfConfig":"27"},{"size":958,"mtime":1634186274843,"results":"41","hashOfConfig":"42"},{"size":550,"mtime":1635427705089,"results":"43","hashOfConfig":"42"},{"size":362,"mtime":1633866378915,"results":"44","hashOfConfig":"42"},{"size":292,"mtime":1634289166201,"results":"45","hashOfConfig":"42"},{"size":7469,"mtime":1636256310065,"results":"46","hashOfConfig":"42"},{"size":3934,"mtime":1636261742527,"results":"47","hashOfConfig":"42"},{"size":3170,"mtime":1636456499468,"results":"48","hashOfConfig":"42"},{"size":9636,"mtime":1636256307201,"results":"49","hashOfConfig":"42"},{"size":31030,"mtime":1636431034686,"results":"50","hashOfConfig":"42"},{"size":2578,"mtime":1636428442297,"results":"51","hashOfConfig":"42"},{"size":975,"mtime":1635869485998,"results":"52","hashOfConfig":"42"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},"53zefd",{"filePath":"56","messages":"57","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"55"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"55"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"55"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"55"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"55"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"79","messages":"80","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"81","messages":"82","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"89"},"p2zgm5",{"filePath":"90","messages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"89"},{"filePath":"92","messages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"89"},{"filePath":"94","messages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"89"},{"filePath":"96","messages":"97","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"98","usedDeprecatedRules":"89"},{"filePath":"99","messages":"100","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"101","usedDeprecatedRules":"89"},{"filePath":"102","messages":"103","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104"},{"filePath":"105","messages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"89"},{"filePath":"108","messages":"109","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"110","usedDeprecatedRules":"89"},{"filePath":"111","messages":"112","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"113","usedDeprecatedRules":"89"},{"filePath":"114","messages":"115","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"89"},"/Users/sinhyeonsu/Documents/coingetprice2/src/index.js",[],["117","118"],"/Users/sinhyeonsu/Documents/coingetprice2/src/App.js",["119","120","121","122","123","124","125","126"],"/Users/sinhyeonsu/Documents/coingetprice2/src/reportWebVitals.js",[],"/Users/sinhyeonsu/Documents/coingetprice2/src/Reducer/index.js",[],"/Users/sinhyeonsu/Documents/coingetprice2/src/Reducer/coinReducer.js",["127","128","129","130","131","132","133","134","135"],"\nimport React from 'react';\nimport { takeEvery, call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { upbitoinApi, bithumbcoinApi, binancecoinApi } from \"../Api/api\";\nimport { createConnectSocketSaga, createRequestSaga, requestActions, createInitRequestSaga, connectBithumbSocketThunk, bitcreateConnectSocketSaga } from '../Lib/asyncUtil';\nimport { coinListDataUtils, coinReadDataUtils } from '../Lib/utils';\n\nconst START_INIT = \"START_INIT\";\nconst START_INIT_ASYNC = \"START_INIT_ASYNC\";\n\nconst GET_UPBIT_MARKET_NAMES = \"GET_UPBIT_MARKET_NAMES\";\nconst GET_UPBIT_MARKET_NAMES_SUCCESS = \"GET_UPBIT_MARKET_NAMES_SUCCESS\";\nconst GET_UPBIT_MARKET_NAMES_ERROR = \"GET_UPBIT_MARKET_NAMES_ERROR\";\n\nconst GET_UPBIT_MARKET_PRICE_INIT = \"GET_UPBIT_MARKET_PRICE_INIT\";\nconst GET_UPBIT_MARKET_PRICE_INIT_SUCCESS = \"GET_UPBIT_MARKET_PRICE_INIT_SUCCESS\";\nconst GET_UPBIT_MARKET_PRICE_INIT_ERROR = \"GET_UPBIT_MARKET_PRICE_INIT_ERROR\";\n\nconst GET_BITHUMB_MARKET_KRW_NAMES = \"GET_BITHUMB_MARKET_KRW_NAMES\";\nconst GET_BITHUMB_MARKET_KRW_NAMES_SUCCESS = \"GET_BITHUMB_MARKET_KRW_NAMES_SUCCESS\";\nconst GET_BITHUMB_MARKET_KRW_NAMES_ERROR = \"GET_BITHUMB_MARKET_KRW_NAMES_ERROR\";\n\nconst GET_BITHUMB_MARKET_BTC_NAMES = \"GET_BITHUMB_MARKET_BTC_NAMES\";\nconst GET_BITHUMB_MARKET_BTC_NAMES_SUCCESS = \"GET_BITHUMB_MARKET_BTC_NAMES_SUCCESS\";\nconst GET_BITHUMB_MARKET_BTC_NAMES_ERROR = \"GET_BITHUMB_MARKET_BTC_NAMES_ERROR\";\n\nconst CONNECT_UPBIT_SOCKET = \"CONNECT_UPBIT_SOCKET\";\nconst CONNECT_UPBIT_SOCKET_SUCCESS = \"CONNECT_UPBIT_SOCKET_SUCCESS\";\nconst CONNECT_UPBIT_SOCKET_ERROR = \"CONNECT_UPBIT_SOCKET_ERROR\";\n\nconst CONNECT_BITHUMB_SOCKET = \"CONNECT_BITHUMB_SOCKET\";\nconst CONNECT_BITHUMB_SOCKET_SUCCESS = \"CONNECT_BITHUMB_SOCKET_SUCCESS\";\nconst CONNECT_BITHUMB_SOCKET_ERROR = \"CONNECT_BITHUMB_SOCKET_ERROR\";\n\nconst CREATE_UPBIT_INIT = \"CREATE_UPBIT_INIT\";\nconst CREATE_UPBIT_INIT_SUCCESS = \"CREATE_UPBIT_INIT_SUCCESS\";\nconst CREATE_UPBIT_INIT_ERROR = \"CREATE_UPBIT_INIT_ERROR\";\n\nconst CREATE_BITHUMB_INIT = \"CREATE_BITHUMB_INIT\";\nconst CREATE_BITHUMB_INIT_SUCCESS = \"CREATE_BITHUMB_INIT_SUCCESS\";\nconst CREATE_BITHUMB_INIT_ERROR = \"CREATE_BITHUMB_INIT_ERROR\";\n\nconst GET_BINANCE_MARKET_NAMES = \"GET_BINANCE_MARKET_NAMES\";\nconst GET_BINANCE_MARKET_NAMES_SUCCESS = \"GET_BINANCE_MARKET_NAMES_SUCCESS\";\nconst GET_BINANCE_MARKET_NAMES_ERROR = \"GET_BINANCE_MARKET_NAMES_ERROR\";\n\n\nconst startInitAsync = () => ({ type: START_INIT_ASYNC });\nconst startInit = () => ({ type: START_INIT });\n\nconst getBinanceMarketNameSaga = createRequestSaga(\n    GET_BINANCE_MARKET_NAMES,\n    binancecoinApi.getMarketCodes,\n    coinListDataUtils.binanceNames\n);\n\nconst getUpbitMarketPriceInitSaga = createRequestSaga(\n    GET_UPBIT_MARKET_PRICE_INIT,\n    upbitoinApi.getMarketPriceCodes,\n    coinListDataUtils.upbitPriceNames\n);\nconst getUpbitAllMarketNameSaga = createRequestSaga(\n    GET_UPBIT_MARKET_NAMES,\n    upbitoinApi.getMarketCodes,\n    coinListDataUtils.upbitAllNames\n);\nconst getBithumbKRWMarketNameSaga = createRequestSaga(\n    GET_BITHUMB_MARKET_KRW_NAMES,\n    bithumbcoinApi.getKRWMarketCodes,\n    coinListDataUtils.bithumbKRWNames\n);\nconst getBithumbBTCMarketNameSaga = createRequestSaga(\n    GET_BITHUMB_MARKET_BTC_NAMES,\n    bithumbcoinApi.getBTCMarketCodes,\n    coinListDataUtils.bithumbBTCNames\n);\n\n\n\n//✅ 업비트 소켓 연결\nconst connectUpbitSocketSaga = createConnectSocketSaga(\n    CONNECT_UPBIT_SOCKET,\n    \"ticker\",\n    coinReadDataUtils.upbitUpdates\n);\n//✅ 빗썸 소켓 연결\nconst connectBithumbSocketSaga = bitcreateConnectSocketSaga(\n    CONNECT_BITHUMB_SOCKET,\n    \"ticker\",\n    coinReadDataUtils.bithumbUpdates\n);\n\nconst createUpbitInitSocketSaga = createInitRequestSaga(\n    CREATE_UPBIT_INIT,\n    coinReadDataUtils.upbitInitNames\n);\n\nconst createBithumbInitSocketSaga = createInitRequestSaga(\n    CREATE_BITHUMB_INIT,\n    coinReadDataUtils.bithumbInitNames\n);\n\n\nfunction* startInitSaga() {\n    yield getUpbitAllMarketNameSaga();\n    yield getUpbitMarketPriceInitSaga();\n\n    yield getBithumbKRWMarketNameSaga();\n    yield getBithumbBTCMarketNameSaga();\n\n    yield getBinanceMarketNameSaga();\n    const state = yield select();\n    //const upbitmarketNames = Object.keys(state.Coin.upbitTotalNames.data);\n    const upbitmarketNames = state.Coin.upbitTotalNames.data;\n    yield createUpbitInitSocketSaga({ payload: upbitmarketNames });\n\n    const bithumbmarketNames = state.Coin.bithumbTotalNames.data;\n    yield createBithumbInitSocketSaga({ payload: bithumbmarketNames });\n\n    const marketNames = Object.keys(state.Coin.upbitTotalNames.data);\n    yield connectUpbitSocketSaga({ payload: marketNames });\n}\nfunction* coinSaga() {\n    yield takeEvery(START_INIT, startInitSaga);\n}\n\nconst initialState = {\n    upbitTotalNames: {\n        data: {\n            \"KRW-BTC\": \"\"\n        },\n    },\n    bithumbTotalNames: {\n        data: {\n            \"BTC_KRW\": \"\"\n        },\n    },\n    binanceTotalNames: {\n        data: {\n            \"ETHBTC\": \"\"\n        }\n    },\n    marketNames: {\n        error: false,\n        data: {\n            \"BTC\": {\n                imgsrc: \"\",\n                gecko: \"\",\n                upbitSym: \"\", upbitUSDT: \"\", upbitBTC: \"\",\n                bithumbSym: \"\", bithumbBTC: \"\",\n                upbitPrice: \"\", upbitBTCPrice: \"\", upbitUSDTPrice: \"\",\n                bithumbPrice: \"\", bithumbBTCPrice: \"\",\n                binanBTCSym: \"\", binanBTCPrice: \"\",\n                binanUSDTSym: \"\", binanUSDTPrice: \"\",\n                binanBNBSym: \"\", binanBNBPrice: \"\",\n            },\n        },\n    },\n};\n\nconst coinReducer = (state = initialState, action) => {\n    switch (action.type) {\n        case GET_BINANCE_MARKET_NAMES_SUCCESS:\n        case GET_BINANCE_MARKET_NAMES_ERROR:\n            return requestActions(GET_BINANCE_MARKET_NAMES, \"binanceTotalNames\")(state, action);\n\n        case GET_UPBIT_MARKET_NAMES_SUCCESS:\n        case GET_UPBIT_MARKET_NAMES_ERROR:\n            return requestActions(GET_UPBIT_MARKET_NAMES, \"upbitTotalNames\")(state, action);\n\n        case GET_UPBIT_MARKET_PRICE_INIT_SUCCESS:\n        case GET_UPBIT_MARKET_PRICE_INIT_ERROR:\n            return requestActions(GET_UPBIT_MARKET_PRICE_INIT, \"upbitTotalNames\")(state, action);\n\n        case GET_BITHUMB_MARKET_KRW_NAMES_SUCCESS:\n        case GET_BITHUMB_MARKET_KRW_NAMES_ERROR:\n            return requestActions(GET_BITHUMB_MARKET_KRW_NAMES, \"bithumbTotalNames\")(state, action);\n\n        case GET_BITHUMB_MARKET_BTC_NAMES_SUCCESS:\n        case GET_BITHUMB_MARKET_BTC_NAMES_ERROR:\n            return requestActions(GET_BITHUMB_MARKET_BTC_NAMES, \"bithumbTotalNames\")(state, action);\n\n        case CREATE_UPBIT_INIT_SUCCESS:\n        case CREATE_UPBIT_INIT_ERROR:\n            return requestActions(CREATE_UPBIT_INIT, \"marketNames\")(state, action);\n\n        case CREATE_BITHUMB_INIT_SUCCESS:\n        case CREATE_BITHUMB_INIT_ERROR:\n            return requestActions(CREATE_BITHUMB_INIT, \"marketNames\")(state, action);\n\n        case CONNECT_UPBIT_SOCKET_SUCCESS:\n        case CONNECT_UPBIT_SOCKET_ERROR:\n            return requestActions(CONNECT_UPBIT_SOCKET, \"marketNames\")(state, action);\n\n        case START_INIT:\n            return state;\n        default:\n            return state;\n    }\n}\nexport {\n    coinReducer,\n    coinSaga,\n    startInit,\n    connectUpbitSocketSaga,\n    startInitAsync\n}","/Users/sinhyeonsu/Documents/coingetprice2/src/Api/api.js",["136"],"import axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\n\nexport const upbitoinApi = {\n    getMarketCodes: () =>\n        axios.get(\"https://api.upbit.com/v1/market/all?isDetails=false\"),\n    getMarketPriceCodes: () =>\n        axios.get(`https://api.upbit.com/v1/ticker?markets=KRW-BTC,KRW-ETH,BTC-ETH,BTC-LTC,BTC-XRP,BTC-ETC,BTC-OMG,BTC-CVC,BTC-DGB,BTC-SC,BTC-SNT,BTC-WAVES,BTC-NMR,BTC-XEM,BTC-QTUM,BTC-BAT,BTC-LSK,BTC-STEEM,BTC-DOGE,BTC-BNT,BTC-XLM,BTC-ARDR,BTC-ARK,BTC-STORJ,BTC-GRS,BTC-REP,BTC-RLC,USDT-BTC,USDT-ETH,USDT-LTC,USDT-XRP,USDT-ETC,KRW-NEO,KRW-MTL,KRW-LTC,KRW-XRP,KRW-ETC,KRW-OMG,KRW-SNT,KRW-WAVES,KRW-XEM,KRW-QTUM,KRW-LSK,KRW-STEEM,KRW-XLM,KRW-ARDR,KRW-ARK,KRW-STORJ,KRW-GRS,KRW-REP,KRW-ADA,BTC-ADA,BTC-MANA,USDT-OMG,KRW-SBD,BTC-SBD,KRW-POWR,BTC-POWR,KRW-BTG,USDT-ADA,BTC-DNT,BTC-ZRX,BTC-TRX,BTC-TUSD,BTC-LRC,KRW-ICX,KRW-EOS,USDT-TUSD,KRW-TRX,BTC-POLY,USDT-SC,USDT-TRX,KRW-SC,KRW-ONT,KRW-ZIL,KRW-POLY,KRW-ZRX,KRW-LOOM,BTC-BCH,USDT-BCH,KRW-BCH,BTC-MFT,BTC-LOOM,KRW-BAT,KRW-IOST,BTC-RFR,KRW-RFR,USDT-DGB,KRW-CVC,KRW-IQ,KRW-IOTA,BTC-RVN,BTC-GO,BTC-UPP,BTC-ENJ,KRW-MFT,KRW-ONG,KRW-GAS,BTC-MTL,KRW-UPP,KRW-ELF,USDT-DOGE,USDT-ZRX,USDT-RVN,USDT-BAT,KRW-KNC,BTC-MOC,BTC-ZIL,KRW-BSV,BTC-BSV,BTC-IOST,KRW-THETA,BTC-DENT,KRW-QKC,BTC-ELF,KRW-BTT,BTC-BTT,BTC-IOTX,BTC-SOLVE,BTC-NKN,BTC-META,KRW-MOC,BTC-ANKR,BTC-CRO,KRW-ENJ,KRW-TFUEL,KRW-MANA,KRW-ANKR,BTC-ORBS,BTC-AERGO,KRW-AERGO,KRW-ATOM,KRW-TT,KRW-CRE,BTC-ATOM,BTC-STPT,KRW-MBL,BTC-EOS,BTC-LUNA,BTC-DAI,BTC-MKR,BTC-BORA,KRW-WAXP,BTC-WAXP,KRW-HBAR,KRW-MED,BTC-MED,BTC-MLK,KRW-MLK,KRW-STPT,BTC-VET,KRW-ORBS,BTC-CHZ,KRW-VET,BTC-FX,BTC-OGN,KRW-CHZ,BTC-XTZ,BTC-HIVE,BTC-HBD,BTC-OBSR,BTC-DKA,KRW-STMX,BTC-STMX,BTC-AHT,BTC-PCI,KRW-DKA,BTC-LINK,KRW-HIVE,KRW-KAVA,BTC-KAVA,KRW-AHT,KRW-LINK,KRW-XTZ,KRW-BORA,BTC-JST,BTC-CHR,BTC-DAD,BTC-TON,KRW-JST,BTC-CTSI,BTC-DOT,KRW-CRO,BTC-COMP,BTC-SXP,BTC-HUNT,KRW-TON,BTC-ONIT,BTC-CRV,BTC-ALGO,BTC-RSR,KRW-SXP,BTC-OXT,BTC-PLA,KRW-HUNT,BTC-MARO,BTC-SAND,BTC-SUN,KRW-PLA,KRW-DOT,BTC-SRM,BTC-QTCON,BTC-MVL,KRW-SRM,KRW-MVL,BTC-GXC,BTC-AQT,BTC-AXS,BTC-STRAX,KRW-STRAX,KRW-AQT,BTC-GLM,KRW-GLM,BTC-FCT2,BTC-SSX,KRW-SSX,KRW-META,KRW-FCT2,BTC-FIL,BTC-UNI,BTC-BASIC,BTC-INJ,BTC-PROM,BTC-VAL,BTC-PSG,BTC-JUV,BTC-CBK,BTC-FOR,KRW-CBK,BTC-BFC,BTC-LINA,BTC-HUM,BTC-CELO,KRW-SAND,KRW-HUM,BTC-IQ,BTC-STX,KRW-DOGE,BTC-NEAR,BTC-AUCTION,BTC-DAWN,BTC-FLOW,BTC-STRK,KRW-STRK,BTC-PUNDIX,KRW-PUNDIX,KRW-FLOW,KRW-DAWN,KRW-AXS,KRW-STX,BTC-GRT,BTC-SNX,BTC-USDP,KRW-XEC,KRW-SOL,BTC-SOL,KRW-MATIC,BTC-MATIC,KRW-NU,BTC-NU`)\n};\n\n\nexport const binancecoinApi = {\n    getMarketCodes: () =>\n        axios.get(\"https://api1.binance.com/api/v3/ticker/price\")\n};\n\nconst geckoObj = () => {\n    var newSymbol = [];\n    CoinMarketData.map((name) => {\n        if (name.totalName)\n            newSymbol.push(name.totalName);\n\n    })\n\n    return newSymbol;\n}\n\n\nexport const geckoApi = {\n    getMarketCodes: () =>\n        axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${geckoObj()}&vs_currencies=usd`)\n};\n\n\n\nexport const bithumbcoinApi = {\n    getKRWMarketCodes: () =>\n        axios.get(\"https://api.bithumb.com/public/ticker/ALL_KRW\"),\n    getBTCMarketCodes: () =>\n        axios.get(\"https://api.bithumb.com/public/ticker/ALL_BTC\")\n};","/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/utils.js",["137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167"],"import { takeEvery, call, put, select, flush, delay } from \"redux-saga/effects\";\nimport axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\nimport { conforms, max } from \"lodash\";\n\nconst coinListDataUtils = {\n    marketNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            let shortSym = name.market.split(\"-\")[1];\n            let moneySym = name.market.split(\"-\")[0];\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitSym: name.market\n                }\n            } else if (moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDT: name.market\n                }\n            } else if (moneySym === \"BTC\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTC: name.market\n                }\n            }\n        });\n        return data;\n    },\n    upbitAllNames: (names) => {\n        const data = {};\n        //console.log(names);\n        names.forEach(name => {\n            data[name.market] = {\n                korean: name.korean_name,\n                english: name.english_name,\n            };\n        })\n        return data;\n    },\n    upbitPriceNames: (names, state) => {\n        const coinStateDatas = state.Coin.upbitTotalNames.data;\n\n        names.forEach(name => {\n            //console.log(\"name\", name);\n            let nowPrice = parseFloat(name.trade_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            coinStateDatas[name.market] = {\n                korean: nowPrice,\n            };\n        })\n        return coinStateDatas;\n    },\n\n    binanceNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            }\n\n        })\n        //console.log(data);\n        return data;\n    },\n    bithumbKRWNames: (names) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let nowPrice = parseFloat(names[name].closing_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            data[name + \"_KRW\"] = {\n                korean: nowPrice,\n            };\n        })\n\n        return data;\n    },\n    bithumbBTCNames: (names, state) => {\n        const coinStateDatas = state.Coin.bithumbTotalNames.data;\n\n        Object.keys(names).forEach(name => {\n            let nowPrice = parseFloat(names[name].closing_price);\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            coinStateDatas[name + \"_BTC\"] = {\n                korean: nowPrice,\n            };\n        })\n        return coinStateDatas;\n    }\n};\n\nconst coinReadDataUtils = {\n    upbitUpdates: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //console.log(\"name\", names);\n        names.forEach(name => {\n\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = parseFloat(name.trade_price);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n                //return coinStateDatas;\n            } else if (moneySym === \"USDT\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice\n                }\n                //return coinStateDatas;\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice\n                }\n            }\n        });\n        return coinStateDatas;\n    },\n    getUpbitAllMarketNameSagabithumbUpdates: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        names.forEach(name => {\n\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = name.closePrice;\n\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            } else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice\n                }\n            }\n        });\n        return coinStateDatas;\n    },\n    //✅\n    mixExchangeUpdates: (one_names, two_names, three_names, gecko_data, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        //✅ bithumb\n        two_names.forEach(name => {\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = name.closePrice;\n            var sortOrder = [];\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === \"KRW\") {\n                if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2)\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice,\n                    bithumbKRW_start_per: calper\n                }\n            }\n            else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice\n                }\n            }\n        });\n        //✅ upbit\n        one_names.forEach(name => {\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = name.trade_price;\n            var sortOrder = [];\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n            } else if (moneySym === \"USDT\") {\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (coinStateDatas[shortSym]) {\n                    Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitUSDT') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[1] === 'upbitBTC') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else {\n                    var calper = \"Prepare\";\n                }\n\n\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice,\n\n                    upbitUSDT_start_per: calper,\n                    calKoupbitUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n                var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n                var cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n\n                if (coinStateDatas[shortSym]) {\n                    Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    var calper = 'prepare';\n                    //\n                } else if (sortOrder[0] === 'upbitSym') {\n                    var calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n                }\n\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice,\n                    //!\n                    calKoupbitBTC: cal,\n                    upbitBTC_start_per: calper\n                }\n            }\n\n            if (coinStateDatas['BTC'].upbitPrice) {\n                //@\n                var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n\n                coinStateDatas['USDT'] = {\n                    ...coinStateDatas['USDT'],\n\n                    upbitUSDT: 'USDTKRW',\n                    upbitUSDTPrice: upbitusdtkrw\n                }\n            }\n        });\n\n\n        //✅ binance\n        three_names.forEach(name => {\n            let nowPrice = name.price;\n\n            if (name.symbol === 'TUSDBTC' || name.symbol === 'DAIBTC' || name.symbol === 'REPBUSD' || name.symbol === 'STORJBUSD' || name.symbol === 'DENTBTC' || name.symbol === 'MFTBTC' || name.symbol === 'SUNBTC' || name.symbol === 'BTTBTC') {\n                return coinStateDatas;\n            }\n\n            if (typeof (nowPrice) === 'string')\n                nowPrice = parseFloat(nowPrice);\n\n            if (nowPrice < 1.0) {\n                nowPrice = nowPrice.toFixed(8);\n            }\n            else {\n                nowPrice = nowPrice.toFixed(1);\n            }\n\n            var sortOrder = [];\n\n\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                var len = name.symbol.indexOf('BTC');\n                var coin = name.symbol.slice(0, len);\n                var cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n                var calper;\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    //calper = \"prepare\";\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBTCSym: name.symbol,\n                        binanBTCPrice: nowPrice,\n                        calKobinanBTC: cal,\n                        binBTC_start_per: calper\n                    }\n                }\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                var len = name.symbol.indexOf('USDT');\n\n                var coin = name.symbol.slice(0, len);\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                var calper;\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanUSDTSym: name.symbol,\n                        binanUSDTPrice: nowPrice,\n                        calKoUSDT: cal,//(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                        binUSDT_start_per: calper,\n                    }\n                }\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                var len = name.symbol.indexOf('BUSD');\n                var coin = name.symbol.slice(0, len);\n\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                var calper;\n                if (coinStateDatas[coin]) {\n                    Object.keys(coinStateDatas[coin]).filter((list) => {\n                        if (list === 'upbitSym') {\n                            sortOrder[0] = 'upbitSym';\n                            return sortOrder;\n                        } else if (list === 'upbitUSDT') {\n                            sortOrder[1] = 'upbitUSDT';\n                            return sortOrder;\n                        }\n                        else if (list === 'upbitBTC') {\n                            sortOrder[2] = 'upbitBTC';\n                            return sortOrder;\n                        }\n                    })\n                    if (!sortOrder[0] && !sortOrder[1]) {\n                        sortOrder.splice(0, 2);\n                    }\n                    else if (!sortOrder[0]) {\n                        sortOrder.splice(0, 1);\n                    }\n                    else if (!sortOrder[1]) {\n                        sortOrder.splice(1, 1);\n                    }\n                }\n\n                if (sortOrder[0] === 'upbitBTC') {\n\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                }\n                else if (sortOrder[0] === \"upbitUSDT\") {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n                }\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBNBSym: name.symbol,\n                        binanBNBPrice: nowPrice,\n                        calKoBUSD: cal,//(parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                        binBUSD_start_per: calper,\n                        //calKoUSDT: (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                    }\n                }\n            }\n\n            if (name.symbol === 'BTCBUSD') {\n\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanBNBSym: name.symbol,\n                    binanBNBPrice: nowPrice\n\n                }\n            } else if (name.symbol === 'BTCUSDT') {\n                var cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanUSDTSym: name.symbol,\n                    binanUSDTPrice: nowPrice,\n                    calKoUSDT: cal,\n                    per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n                }\n            }\n        });\n\n        //✅ Max per search\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n\n            // bithumbKRW_start_per\n            // binBUSD_start_per\n            // upbitBTC_start_per\n            // upbitUSDT_start_per\n            // BTCper\n            // binUSDT_start_per\n\n            var maxPer = 0.0;\n            var minPer = 0.0;\n            keyread.forEach((name) => {\n                var per;\n                if (name === 'bithumbKRW_start_per') {\n                    per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n                }\n                else if (name === 'binBUSD_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n                } else if (name === 'upbitBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n                } else if (name === 'upbitUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n                } else if (name === 'BTCper') {\n                    per = parseFloat(coinStateDatas[coin].BTCper);\n                } else if (name === 'binUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n                }\n                else if (name === 'binBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n                }\n                if (per > maxPer) {\n                    maxPer = per;\n                }\n                if (per < minPer) {\n                    minPer = per;\n                }\n            })\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                totalPer: maxPer,\n                totalminPer: minPer\n            }\n        });\n        return coinStateDatas;\n    },\n    //\n    upbitInitNames: (names, state) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n\n            if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                }\n            } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                }\n            }\n        })\n\n        var upbitusdtkrw = (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1);\n\n        data['USDT'] = {\n            ...data['USDT'],\n            upbitUSDTPrice: upbitusdtkrw,\n            upbitUSDT: 'USDTKRW',\n        }\n\n        Object.keys(names).forEach(name => {\n\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n            let imgsrc = \"\";\n            CoinMarketData.find((coin) => {\n                if (coin.symbol === shortSym) {\n                    imgsrc = coin.imgsrc;\n                }\n            })\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                    imgsrc: imgsrc\n                }\n            } else if (moneySym === \"USDT\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                    imgsrc: imgsrc,\n                    calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n                }\n            } else if (moneySym === \"BTC\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTCPrice: names[name].korean,\n                    upbitBTC: name,\n                    imgsrc: imgsrc,\n                    calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        });\n        return data;\n    },\n    bithumbInitNames: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"_\")[0];\n            let moneySym = name.split(\"_\")[1];\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: names[name].korean,\n                    bithumbSym: name,\n                }\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: names[name].korean,\n                    bithumbBTC: name,\n                    calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        })\n\n\n        return coinStateDatas;\n    }\n};\n\n\nexport {\n    coinListDataUtils,\n    coinReadDataUtils\n}","/Users/sinhyeonsu/Documents/coingetprice2/src/Lib/asyncUtil.js",["168","169","170","171","172","173","174","175","176","177","178","179","180","181","182"],"import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\n\nimport { throttle } from \"lodash\";\nimport { coinReadDataUtils } from \"./utils\";\n\nimport axios from \"axios\";\nimport { binancecoinApi, geckoApi, upbitoinApi } from \"../Api/api\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n\n    return function* (action = {}) {\n        var res;\n        const state = yield select();\n\n        if (type === \"GET_UPBIT_MARKET_PRICE_INIT\") {\n            var coinString;\n            Object.keys(state.Coin.upbitTotalNames.data).map((coin) => {\n\n                coinString += coin + \",\"\n            });\n            //✅ coinString 내용을 복사 해서 api getMarketPriceCodes 에 붙여넣기 함.... ;;\n            coinString = coinString.slice(9, -1);\n            res = yield call(api, action.payload);\n        }\n        else {\n            res = yield call(api, action.payload);\n        }\n        try {\n            const state = yield select();\n            if (type === \"GET_UPBIT_MARKET_NAMES\" || type === \"GET_UPBIT_MARKET_PRICE_INIT\" || type === \"GET_BINANCE_MARKET_NAMES\") {\n                yield put({ type: SUCCESS, payload: dataMaker(res.data, state) });\n            }\n            else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\") {\n                //console.log(res.data.data);\n                yield put({ type: SUCCESS, payload: dataMaker(res.data.data, state) });\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        try {\n            const state = yield select();\n            yield put({ type: SUCCESS, payload: dataMaker(action.payload, state) });\n\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\n// requestActions(GET_MARKET_NAMES, \"marketNames\")(state, action);\nconst requestActions = (type, key) => {\n    const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n\n    return (state, action) => {\n        //console.log(state, action);\n        switch (action.type) {\n            case SUCCESS:\n                //console.log(15);\n                return reducerUtils.success(state, action.payload, key);\n            case ERROR:\n                return reducerUtils.error(state, action.payload, key);\n            default:\n                return state;\n        }\n    };\n};\n\nconst reducerUtils = {\n    success: (state, payload, key) => {\n        return {\n            ...state,\n            [key]: {\n                data: payload,\n                error: false,\n            },\n        };\n    },\n    error: (state, error, key) => ({\n        ...state,\n        [key]: {\n            ...state[key],\n            error: error,\n        },\n    }),\n};\n\nconst createUpbitSocket = () => {\n    const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\nconst createBithumbSocket = () => {\n    const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\n\n\n// 소켓 연결용\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(\"action\", action);\n    return eventChannel((emit) => {\n        socket.onopen = () => {\n            //if (type === \"CONNECT_UPBIT_SOCKET\") {\n            socket.send(\n                JSON.stringify([\n                    { ticket: \"coinbread-clone\" },\n                    { type: connectType, codes: action },\n                ])\n            );\n            //} \n            /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                socket.send(\n                    JSON.stringify(\n                        { type: connectType, symbols: action.payload, tickTypes: [\"MID\"] }\n                    )\n                );\n            }*/\n        };\n        socket.onmessage = (evt) => {\n            //upbit\n            //console.log(\"upbit\", evt);\n            //if (type === \"CONNECT_UPBIT_SOCKET\") {\n            const enc = new encoding.TextDecoder(\"utf-8\");\n            const data = JSON.parse(enc.decode(evt.data));\n            emit(data);\n            //} \n            /*else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                emit(JSON.parse(evt.data));\n            }*/\n        };\n\n        socket.onerror = (evt) => {\n            console.log(\"error\", evt);\n            emit(evt);\n            emit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst bitconnectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(type);\n\n    return eventChannel((eemit) => {\n        var count = 0;\n        socket.onopen = () => {\n            socket.send(\n                JSON.stringify(\n                    { type: connectType, symbols: action, tickTypes: [\"MID\"] }\n                )\n            );\n        };\n        socket.onmessage = (evt) => {\n            //console.log(evt.data);\n            const data = JSON.parse(evt.data)\n            if (data && data['type'] === 'ticker') {\n                /*if (count === 0) {\n                    socket.send(\n                        JSON.stringify(\n                            { type: connectType, symbols: [\"ETH_KRW\"], tickTypes: [\"MID\"] }\n                        )\n                    );\n                    count = 1;\n                    console.log(\"0\", data['content']);\n                    eemit(data['content']);\n                }\n                else if (count === 1) {\n                    socket.send(\n                        JSON.stringify(\n                            { type: connectType, symbols: [\"BTC_KRW\"], tickTypes: [\"MID\"] }\n                        )\n                    );\n                    count = 0;\n                    console.log(\"1\", data['content']);\n                    eemit(data['content']);\n                }*/\n                eemit(data['content']);\n            }\n\n        };\n\n        socket.onerror = (evt) => {\n            console.log(\"error\", evt);\n            eemit(evt);\n            eemit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        const state = yield select();\n\n        const upbitTotalNames = Object.keys(state.Coin.upbitTotalNames.data);\n        const bithumbTotalNames = Object.keys(state.Coin.bithumbTotalNames.data);\n\n        var client;\n        var bitclient;\n        var clientChannel;\n        //✅ new\n        var bitclientChannel;\n\n\n        client = yield call(createUpbitSocket);\n\n        bitclient = yield call(createBithumbSocket);\n        //console.log(upbitTotalNames);\n        clientChannel = yield call(\n            connectSocekt,\n            client,\n            connectType,\n            type,\n            upbitTotalNames,\n            buffers.expanding(500)\n        );\n\n        //✅ new\n        bitclientChannel = yield call(\n            bitconnectSocekt,\n            bitclient,\n            connectType,\n            type,\n            bithumbTotalNames,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const bitdatas = yield flush(bitclientChannel);\n\n                var sortedDATA;\n                var sortedData;\n\n                if (datas.length) {\n                    //console.log(datas);\n                    var sortedObj = {};\n                    datas.forEach((data) => {\n                        if (sortedObj[data.code]) {\n                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                            sortedObj[data.code] =\n                                sortedObj[data.code].timestamp > data.timestamp\n                                    ? sortedObj[data.code]\n                                    : data;\n                        } else {\n                            sortedObj[data.code] = data;\n                        }\n                        sortedObj[data.code] = data;\n                        //console.log(sortedObj[data.code]);\n                    });\n\n                    sortedDATA = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n                    //yield put({ type: SUCCESS, payload: dataMaker(sortedDATA, state) });\n\n                    if (bitdatas.length) {\n                        var sortedObj = {};\n                        var binanceObj;\n                        var geckoObj;\n                        //console.log(bitdatas);\n                        bitdatas.forEach((data) => {\n                            if (sortedObj[data.code]) {\n                                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                sortedObj[data.symbol] =\n                                    sortedObj[data.symbol].time > data.time\n                                        ? sortedObj[data.symbol]\n                                        : data;\n                            } else {\n                                sortedObj[data.symbol] = data;\n                            }\n                            sortedObj[data.symbol] = data;\n                            //console.log(sortedObj[data.symbol]);\n                            //console.log(sortedObj);\n                        });\n                        sortedData = Object.keys(sortedObj).map(\n                            (data) => sortedObj[data]\n                        );\n\n\n\n                        binanceObj = yield call(binancecoinApi.getMarketCodes)\n                        //geckoObj = yield call(geckoApi.getMarketCodes)\n\n                        yield put({ type: SUCCESS, payload: coinReadDataUtils.mixExchangeUpdates(sortedDATA, sortedData, binanceObj.data, \"\", state) });\n                        //yield put({ type: SUCCESS, payload: coinReadDataUtils.mixExchangeUpdates(sortedDATA, sortedData, binanceObj.data, geckoObj.data, state) });\n                    }\n\n\n                }\n                yield delay(500); // 500ms 동안 대기\n\n            }\n        } catch (e) {\n            console.log(e);\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }\n    };\n};\n\n\nconst bitcreateConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n    //console.log(\"11\");\n\n    return function* (action = {}) {\n\n        //console.log(\"afsdf\");\n        /*var client;\n        var clientChannel;\n        if (type === \"CONNECT_UPBIT_SOCKET\")\n            client = yield call(createUpbitSocket);\n        else if (type === \"CONNECT_BITHUMB_SOCKET\")\n            client = yield call(createBithumbSocket);\n\n        clientChannel = yield call(\n            bitconnectSocekt,\n            client,\n            connectType,\n            type,\n            action,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const state = yield select();\n\n                if (datas.length) {\n                    const sortedObj = {};\n                    datas.forEach((data) => {\n                        if (type === \"CONNECT_UPBIT_SOCKET\") {\n                            if (sortedObj[data.code]) {\n                                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                sortedObj[data.code] =\n                                    sortedObj[data.code].timestamp > data.timestamp\n                                        ? sortedObj[data.code]\n                                        : data;\n                            } else {\n                                sortedObj[data.code] = data;\n                            }\n                            sortedObj[data.code] = data;\n                        }\n                        else if (type === \"CONNECT_BITHUMB_SOCKET\") {\n                            console.log(\"check\");\n                            if (sortedObj[data.content]) {\n                                sortedObj[data.content] =\n                                    sortedObj[data.content].time > data.time\n                                        ? sortedObj[data.content]\n                                        : data;\n                            } else {\n                                sortedObj[data.content] = data;\n                            }\n                            sortedObj[data.content] = data;\n                        }\n                    });\n\n                    const sortedData = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n\n                    yield put({ type: SUCCESS, payload: dataMaker(sortedData, state) });\n                }\n\n                yield delay(500); // 500ms 동안 대기\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }*/\n        //};\n    }\n};\n\n\n\nexport {\n    createRequestSaga,\n    requestActions,\n    createConnectSocketSaga,\n    createInitRequestSaga,\n    bitcreateConnectSocketSaga\n}","/Users/sinhyeonsu/Documents/coingetprice2/src/container/CoinContainer.js",["183","184","185","186","187","188"],"import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport CoinList from '../components/CoinList';\nimport \"../components/CoinList.css\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\n\nfunction CoinContainer() {\n    var coinTotal = new Object();\n    coinTotal = useSelector((state) => state.Coin.marketNames);\n\n    const upbitCoinList = Object.keys(coinTotal.data);\n    const upbitimgsrc = CoinMarketData[0].imgsrc;\n    const bithumbimgsrc = CoinMarketData[1].imgsrc;\n    const binanceimgsrc = CoinMarketData[2].imgsrc;\n\n    const binanceUsdt = coinTotal.data['USDT'];\n\n\n    if (!binanceUsdt) return null;\n    if (!coinTotal) return null;\n\n\n\n    upbitCoinList.sort((next, prev) => {\n        if (parseFloat(coinTotal.data[next].totalPer) > parseFloat(coinTotal.data[prev].totalPer))\n            return -1;\n        else\n            return 0;\n    });\n\n\n\n    return (\n\n        <div>\n            <div className='coin-container'>\n                <div className=\"coin-row\" >\n                    <img className=\"exchange-img\" src={upbitimgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {binanceUsdt.upbitUSDT}\n                        </p>\n                        <p className=\"coin-price\">\n                            {binanceUsdt.upbitUSDTPrice}\n                        </p>\n                    </div>\n\n                </div>\n            </div>\n            {\n                upbitCoinList.map((coinData) => {\n                    if (coinData !== 'USDT')\n                        return <CoinList key={`coinlist-${coinData}`} one_coin={coinTotal.data[coinData]} one_coin_Sym={coinData} />\n                })\n            }\n        </div>\n    )\n    //<CoinList coins={coinTotal.data} />\n}\n\nexport default CoinContainer;","/Users/sinhyeonsu/Documents/coingetprice2/src/components/CoinList.js",["189","190","191","192","193","194","195","196","197","198","199","200","201"],"/Users/sinhyeonsu/Documents/coingetprice2/src/Router.js",["202"],"/Users/sinhyeonsu/Documents/coingetprice2/src/routes/Auth.js",["203","204","205","206","207","208"],"/Users/sinhyeonsu/Documents/coingetprice2/src/routes/Home.js",[],"/Users/sinhyeonsu/Documents/coingetprice2/src/fbase.js",[],"/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/index.js",[],["209","210"],"/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/App.js",[],"/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/reportWebVitals.js",[],"/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Reducer/index.js",[],"/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Reducer/coinReducer.js",["211","212"],"import { takeEvery, select, } from \"redux-saga/effects\";\nimport { upbitoinApi, bithumbcoinApi, binancecoinApi, kucoinApi } from \"../Api/api\";\nimport { createConnectSocketSaga, createRequestSaga, requestActions, createInitRequestSaga } from '../Lib/asyncUtil';\nimport { coinListDataUtils, coinReadDataUtils } from '../Lib/utils';\n\nconst START_INIT = \"START_INIT\";\nconst START_INIT_ASYNC = \"START_INIT_ASYNC\";\n\n\nconst GET_KUCOIN_MARKET_NAMES = \"GET_KUCOIN_MARKET_NAMES\";\nconst GET_KUCOIN_MARKET_NAMES_SUCCESS = \"GET_KUCOIN_MARKET_NAMES_SUCCESS\";\nconst GET_KUCOIN_MARKET_NAMES_ERROR = \"GET_KUCOIN_MARKET_NAMES_ERROR\";\n\nconst GET_UPBIT_MARKET_NAMES = \"GET_UPBIT_MARKET_NAMES\";\nconst GET_UPBIT_MARKET_NAMES_SUCCESS = \"GET_UPBIT_MARKET_NAMES_SUCCESS\";\nconst GET_UPBIT_MARKET_NAMES_ERROR = \"GET_UPBIT_MARKET_NAMES_ERROR\";\n\nconst GET_UPBIT_MARKET_PRICE_INIT = \"GET_UPBIT_MARKET_PRICE_INIT\";\nconst GET_UPBIT_MARKET_PRICE_INIT_SUCCESS = \"GET_UPBIT_MARKET_PRICE_INIT_SUCCESS\";\nconst GET_UPBIT_MARKET_PRICE_INIT_ERROR = \"GET_UPBIT_MARKET_PRICE_INIT_ERROR\";\n\nconst GET_BITHUMB_MARKET_KRW_NAMES = \"GET_BITHUMB_MARKET_KRW_NAMES\";\nconst GET_BITHUMB_MARKET_KRW_NAMES_SUCCESS = \"GET_BITHUMB_MARKET_KRW_NAMES_SUCCESS\";\nconst GET_BITHUMB_MARKET_KRW_NAMES_ERROR = \"GET_BITHUMB_MARKET_KRW_NAMES_ERROR\";\n\nconst GET_BITHUMB_MARKET_BTC_NAMES = \"GET_BITHUMB_MARKET_BTC_NAMES\";\nconst GET_BITHUMB_MARKET_BTC_NAMES_SUCCESS = \"GET_BITHUMB_MARKET_BTC_NAMES_SUCCESS\";\nconst GET_BITHUMB_MARKET_BTC_NAMES_ERROR = \"GET_BITHUMB_MARKET_BTC_NAMES_ERROR\";\n\nconst CONNECT_UPBIT_SOCKET = \"CONNECT_UPBIT_SOCKET\";\nconst CONNECT_UPBIT_SOCKET_SUCCESS = \"CONNECT_UPBIT_SOCKET_SUCCESS\";\nconst CONNECT_UPBIT_SOCKET_ERROR = \"CONNECT_UPBIT_SOCKET_ERROR\";\n\nconst CREATE_UPBIT_INIT = \"CREATE_UPBIT_INIT\";\nconst CREATE_UPBIT_INIT_SUCCESS = \"CREATE_UPBIT_INIT_SUCCESS\";\nconst CREATE_UPBIT_INIT_ERROR = \"CREATE_UPBIT_INIT_ERROR\";\n\nconst CREATE_BITHUMB_INIT = \"CREATE_BITHUMB_INIT\";\nconst CREATE_BITHUMB_INIT_SUCCESS = \"CREATE_BITHUMB_INIT_SUCCESS\";\nconst CREATE_BITHUMB_INIT_ERROR = \"CREATE_BITHUMB_INIT_ERROR\";\n\nconst GET_BINANCE_MARKET_NAMES = \"GET_BINANCE_MARKET_NAMES\";\nconst GET_BINANCE_MARKET_NAMES_SUCCESS = \"GET_BINANCE_MARKET_NAMES_SUCCESS\";\nconst GET_BINANCE_MARKET_NAMES_ERROR = \"GET_BINANCE_MARKET_NAMES_ERROR\";\n\n\nconst startInitAsync = () => ({ type: START_INIT_ASYNC });\nconst startInit = () => ({ type: START_INIT });\n\n//✅ Kucoin\nconst getKucoinAllMarketNameSaga = createRequestSaga(\n    GET_KUCOIN_MARKET_NAMES,\n    kucoinApi.getMarketCodes,\n    coinListDataUtils.kucoinAllNames\n);\n\nconst getUpbitAllMarketNameSaga = createRequestSaga(\n    GET_UPBIT_MARKET_NAMES,\n    upbitoinApi.getMarketCodes,\n    coinListDataUtils.upbitAllNames\n);\nconst getBinanceMarketNameSaga = createRequestSaga(\n    GET_BINANCE_MARKET_NAMES,\n    binancecoinApi.getMarketCodes,\n    coinListDataUtils.binanceNames\n);\nconst getBithumbKRWMarketNameSaga = createRequestSaga(\n    GET_BITHUMB_MARKET_KRW_NAMES,\n    bithumbcoinApi.getKRWMarketCodes,\n    coinListDataUtils.bithumbKRWNames\n);\nconst getBithumbBTCMarketNameSaga = createRequestSaga(\n    GET_BITHUMB_MARKET_BTC_NAMES,\n    bithumbcoinApi.getBTCMarketCodes,\n    coinListDataUtils.bithumbBTCNames\n);\n\nconst getUpbitMarketPriceInitSaga = createRequestSaga(\n    GET_UPBIT_MARKET_PRICE_INIT,\n    upbitoinApi.getMarketPriceCodes,\n    coinListDataUtils.upbitPriceNames\n);\n\n\n\n\n//✅ 업비트 소켓 연결\nconst connectUpbitSocketSaga = createConnectSocketSaga(\n    CONNECT_UPBIT_SOCKET,\n    \"ticker\",\n    coinReadDataUtils.upbitUpdates\n);\n\nconst createUpbitInitSocketSaga = createInitRequestSaga(\n    CREATE_UPBIT_INIT,\n    coinReadDataUtils.upbitInitNames\n);\n//✅ 빗썸 소켓 연결\nconst createBithumbInitSocketSaga = createInitRequestSaga(\n    CREATE_BITHUMB_INIT,\n    coinReadDataUtils.bithumbInitNames\n);\n\n\nfunction* startInitSaga() {\n    yield getUpbitAllMarketNameSaga();\n    yield getUpbitMarketPriceInitSaga();\n\n    yield getBithumbKRWMarketNameSaga();\n    yield getBithumbBTCMarketNameSaga();\n\n    yield getBinanceMarketNameSaga();\n\n    //✅ kucoin\n    yield getKucoinAllMarketNameSaga();\n    const state = yield select();\n\n    const upbitmarketNames = state.Coin.upbitTotalNames.data;\n    yield createUpbitInitSocketSaga({ payload: upbitmarketNames });\n\n    const bithumbmarketNames = state.Coin.bithumbTotalNames.data;\n    yield createBithumbInitSocketSaga({ payload: bithumbmarketNames });\n\n    const marketNames = Object.keys(state.Coin.upbitTotalNames.data);\n    yield connectUpbitSocketSaga({ payload: marketNames });\n}\nfunction* coinSaga() {\n    yield takeEvery(START_INIT, startInitSaga);\n}\n\nconst initialState = {\n    upbitTotalNames: {\n        data: {\n            \"KRW-BTC\": \"\"\n        },\n    },\n    bithumbTotalNames: {\n        data: {\n            \"BTC_KRW\": \"\"\n        },\n    },\n    binanceTotalNames: {\n        data: {\n            \"ETHBTC\": \"\"\n        }\n    },\n    marketNames: {\n        error: false,\n        data: {\n            \"BTC\": {\n                imgsrc: \"\",\n                gecko: \"\",\n                upbitSym: \"\", upbitPrice: \"\",\n                upbitBTC: \"\", upbitBTCPrice: \"\",\n                upbitUSDT: \"\", upbitUSDTPrice: \"\",\n                bithumbSym: \"\", bithumbPrice: \"\",\n                bithumbBTC: \"\", bithumbBTCPrice: \"\",\n                binanBTCSym: \"\", binanBTCPrice: \"\",\n                binanUSDTSym: \"\", binanUSDTPrice: \"\",\n                binanBNBSym: \"\", binanBNBPrice: \"\",\n\n                calKoupbitBTC: \"\",\n                calKobithumbBTC: \"\",\n                calKobinanBTC: \"\",\n                calKoupbitUSDT: \"\",\n                calKoUSDT: \"\",\n                calKoBUSD: \"\"\n            },\n        },\n    },\n    TOPmarketString: [],\n    TOPmarketNames: [],\n};\n\nconst coinReducer = (state = initialState, action) => {\n    switch (action.type) {\n        case GET_BINANCE_MARKET_NAMES_SUCCESS:\n        case GET_BINANCE_MARKET_NAMES_ERROR:\n            return requestActions(GET_BINANCE_MARKET_NAMES, \"binanceTotalNames\")(state, action);\n\n        case GET_UPBIT_MARKET_NAMES_SUCCESS:\n        case GET_UPBIT_MARKET_NAMES_ERROR:\n            return requestActions(GET_UPBIT_MARKET_NAMES, \"upbitTotalNames\")(state, action);\n\n        case GET_UPBIT_MARKET_PRICE_INIT_SUCCESS:\n        case GET_UPBIT_MARKET_PRICE_INIT_ERROR:\n            return requestActions(GET_UPBIT_MARKET_PRICE_INIT, \"upbitTotalNames\")(state, action);\n\n        case GET_BITHUMB_MARKET_KRW_NAMES_SUCCESS:\n        case GET_BITHUMB_MARKET_KRW_NAMES_ERROR:\n            return requestActions(GET_BITHUMB_MARKET_KRW_NAMES, \"bithumbTotalNames\")(state, action);\n\n        case GET_BITHUMB_MARKET_BTC_NAMES_SUCCESS:\n        case GET_BITHUMB_MARKET_BTC_NAMES_ERROR:\n            return requestActions(GET_BITHUMB_MARKET_BTC_NAMES, \"bithumbTotalNames\")(state, action);\n\n        case CREATE_UPBIT_INIT_SUCCESS:\n        case CREATE_UPBIT_INIT_ERROR:\n            return requestActions(CREATE_UPBIT_INIT, \"marketNames\")(state, action);\n\n        case CREATE_BITHUMB_INIT_SUCCESS:\n        case CREATE_BITHUMB_INIT_ERROR:\n            return requestActions(CREATE_BITHUMB_INIT, \"marketNames\")(state, action);\n\n        case CONNECT_UPBIT_SOCKET_SUCCESS:\n        case CONNECT_UPBIT_SOCKET_ERROR:\n            return requestActions(CONNECT_UPBIT_SOCKET, \"marketNames\")(state, action);\n\n        case START_INIT:\n            return state;\n        default:\n            return state;\n    }\n}\nexport {\n    coinReducer,\n    coinSaga,\n    startInit,\n    connectUpbitSocketSaga,\n    startInitAsync\n}","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/container/CoinContainer.js",["213","214","215","216","217","218","219"],"import React from 'react';\nimport { useSelector } from 'react-redux';\nimport CoinList from '../components/CoinList';\nimport \"../components/CoinList.css\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\n\nfunction CoinContainer() {\n    var coinTotal = useSelector((state) => state.Coin.marketNames);\n\n    var TOPcoinTotalmain = useSelector((state) => state.Coin.TOPmarketNames);\n    //console.log(TOPcoinTotalmain);\n    const TOPcoinTotal = Object.keys(TOPcoinTotalmain);\n\n    const binanceUsdt = coinTotal.data['USDT'];\n    const BTCdata = coinTotal.data['BTC'];\n\n\n    if (!TOPcoinTotalmain) return null;\n    if (!binanceUsdt) return null;\n    if (!coinTotal) return null;\n\n    TOPcoinTotalmain.sort((next, prev) => {\n        var nextsym = next[0].MainSym;\n        var prevsym = prev[0].MainSym;\n\n        if (parseFloat(coinTotal.data[nextsym].testper) > parseFloat(coinTotal.data[prevsym].testper)) {\n            return -1;\n        }\n        else\n            return 0;\n    });\n\n\n    return (\n        <div>\n            <div className='coin-container'>\n                <div className=\"coin-row\" >\n                    <img className=\"exchange-img\" src={CoinMarketData[0].imgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {binanceUsdt.upbitUSDT}\n                        </p>\n                        <p className=\"coin-price\">\n                            {binanceUsdt.upbitUSDTPrice}\n                        </p>\n                    </div>\n\n\n                    <img className=\"exchange-img\" src={CoinMarketData[0].imgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {BTCdata.upbitSym}\n                        </p>\n                        <p className=\"coin-price\">\n                            {BTCdata.upbitPrice}\n                        </p>\n                    </div>\n\n                    <img className=\"exchange-img\" src={CoinMarketData[0].imgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {BTCdata.upbitUSDT}\n                        </p>\n                        <p className=\"coin-price\">\n                            {BTCdata.upbitUSDTPrice}\n                        </p>\n                    </div>\n\n\n                    <img className=\"exchange-img\" src={CoinMarketData[1].imgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {BTCdata.bithumbSym}\n                        </p>\n                        <p className=\"coin-price\">\n                            {BTCdata.bithumbPrice}\n                        </p>\n                    </div>\n\n\n                    <img className=\"exchange-img\" src={CoinMarketData[2].imgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {BTCdata.binanUSDTSym}\n                        </p>\n                        <p className=\"coin-price\">\n                            {BTCdata.binanUSDTPrice}\n                        </p>\n                    </div>\n                    <img className=\"exchange-img\" src={CoinMarketData[2].imgsrc} />\n                    <div classame=\"coin-data\">\n                        <p className=\"coin-price\">\n                            {BTCdata.binanBNBSym}\n                        </p>\n                        <p className=\"coin-price\">\n                            {BTCdata.binanBNBPrice}\n                        </p>\n                    </div>\n                </div>\n\n\n            </div>\n\n            {\n                TOPcoinTotalmain.map((one_coin) => {\n                    return <CoinList key={`cccoinlist__${one_coin[0].MainSym}`} one_coin={one_coin} />;\n                })\n            }\n        </div>\n    )\n}\n\nexport default CoinContainer;\n","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Api/api.js",["220","221","222","223","224","225","226","227"],"import axios from \"axios\";\nimport { useSelector } from 'react-redux';\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\nimport { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport cors from 'cors';\n\nexport const kucoinApi = {\n    getMarketCodes: () =>\n        axios.get(\"/api/v1/symbols\"),\n    getMarketPriceCodes: () => {\n        return axios.get(`https://api.upbit.com/v1/ticker?markets=KRW-BTC,KRW-ETH,BTC-ETH,BTC-LTC,BTC-XRP,BTC-ETC,BTC-OMG,BTC-CVC,BTC-DGB,BTC-SC,BTC-SNT,BTC-WAVES,BTC-NMR,BTC-XEM,BTC-QTUM,BTC-BAT,BTC-LSK,BTC-STEEM,BTC-DOGE,BTC-BNT,BTC-XLM,BTC-ARDR,BTC-ARK,BTC-STORJ,BTC-GRS,BTC-REP,BTC-RLC,USDT-BTC,USDT-ETH,USDT-LTC,USDT-XRP,USDT-ETC,KRW-NEO,KRW-MTL,KRW-LTC,KRW-XRP,KRW-ETC,KRW-OMG,KRW-SNT,KRW-WAVES,KRW-XEM,KRW-QTUM,KRW-LSK,KRW-STEEM,KRW-XLM,KRW-ARDR,KRW-ARK,KRW-STORJ,KRW-GRS,KRW-REP,KRW-ADA,BTC-ADA,BTC-MANA,USDT-OMG,KRW-SBD,BTC-SBD,KRW-POWR,BTC-POWR,KRW-BTG,USDT-ADA,BTC-DNT,BTC-ZRX,BTC-TRX,BTC-TUSD,BTC-LRC,KRW-ICX,KRW-EOS,USDT-TUSD,KRW-TRX,BTC-POLY,USDT-SC,USDT-TRX,KRW-SC,KRW-ONT,KRW-ZIL,KRW-POLY,KRW-ZRX,KRW-LOOM,BTC-BCH,USDT-BCH,KRW-BCH,BTC-MFT,BTC-LOOM,KRW-BAT,KRW-IOST,BTC-RFR,KRW-RFR,USDT-DGB,KRW-CVC,KRW-IQ,KRW-IOTA,BTC-RVN,BTC-GO,BTC-UPP,BTC-ENJ,KRW-MFT,KRW-ONG,KRW-GAS,BTC-MTL,KRW-UPP,KRW-ELF,USDT-DOGE,USDT-ZRX,USDT-RVN,USDT-BAT,KRW-KNC,BTC-MOC,BTC-ZIL,KRW-BSV,BTC-BSV,BTC-IOST,KRW-THETA,BTC-DENT,KRW-QKC,BTC-ELF,KRW-BTT,BTC-BTT,BTC-IOTX,BTC-SOLVE,BTC-NKN,BTC-META,KRW-MOC,BTC-ANKR,BTC-CRO,KRW-ENJ,KRW-TFUEL,KRW-MANA,KRW-ANKR,BTC-ORBS,BTC-AERGO,KRW-AERGO,KRW-ATOM,KRW-TT,KRW-CRE,BTC-ATOM,BTC-STPT,KRW-MBL,BTC-EOS,BTC-LUNA,BTC-DAI,BTC-MKR,BTC-BORA,KRW-WAXP,BTC-WAXP,KRW-HBAR,KRW-MED,BTC-MED,BTC-MLK,KRW-MLK,KRW-STPT,BTC-VET,KRW-ORBS,BTC-CHZ,KRW-VET,BTC-FX,BTC-OGN,KRW-CHZ,BTC-XTZ,BTC-HIVE,BTC-HBD,BTC-OBSR,BTC-DKA,KRW-STMX,BTC-STMX,BTC-AHT,BTC-PCI,KRW-DKA,BTC-LINK,KRW-HIVE,KRW-KAVA,BTC-KAVA,KRW-AHT,KRW-LINK,KRW-XTZ,KRW-BORA,BTC-JST,BTC-CHR,BTC-DAD,BTC-TON,KRW-JST,BTC-CTSI,BTC-DOT,KRW-CRO,BTC-COMP,BTC-SXP,BTC-HUNT,KRW-TON,BTC-ONIT,BTC-CRV,BTC-ALGO,BTC-RSR,KRW-SXP,BTC-OXT,BTC-PLA,KRW-HUNT,BTC-MARO,BTC-SAND,BTC-SUN,KRW-PLA,KRW-DOT,BTC-SRM,BTC-QTCON,BTC-MVL,KRW-SRM,KRW-MVL,BTC-GXC,BTC-AQT,BTC-AXS,BTC-STRAX,KRW-STRAX,KRW-AQT,BTC-GLM,KRW-GLM,BTC-FCT2,BTC-SSX,KRW-SSX,KRW-META,KRW-FCT2,BTC-FIL,BTC-UNI,BTC-BASIC,BTC-INJ,BTC-PROM,BTC-VAL,BTC-PSG,BTC-JUV,BTC-CBK,BTC-FOR,KRW-CBK,BTC-BFC,BTC-LINA,BTC-HUM,BTC-CELO,KRW-SAND,KRW-HUM,BTC-IQ,BTC-STX,KRW-DOGE,BTC-NEAR,BTC-AUCTION,BTC-DAWN,BTC-FLOW,BTC-STRK,KRW-STRK,BTC-PUNDIX,KRW-PUNDIX,KRW-FLOW,KRW-DAWN,KRW-AXS,KRW-STX,BTC-GRT,BTC-SNX,BTC-USDP,KRW-XEC,KRW-SOL,BTC-SOL,KRW-MATIC,BTC-MATIC,KRW-NU,BTC-NU`)\n    }\n};\n\nexport const upbitoinApi = {\n    getMarketCodes: () =>\n        axios.get(\"https://api.upbit.com/v1/market/all?isDetails=false\"),\n    getMarketPriceCodes: () => {\n        return;\n    }\n};\n\nexport const binancecoinApi = {\n    getMarketCodes: () =>\n        axios.get(\"https://api1.binance.com/api/v3/ticker/price\")\n};\n\n\nexport const bithumbcoinApi = {\n    getKRWMarketCodes: () =>\n        axios.get(\"https://api.bithumb.com/public/ticker/ALL_KRW\"),\n    getBTCMarketCodes: () =>\n        axios.get(\"https://api.bithumb.com/public/ticker/ALL_BTC\")\n};\n\n","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/asyncUtil.js",["228","229","230","231","232","233","234","235"],"import { call, put, select, flush, delay } from \"redux-saga/effects\";\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\nimport { buffers, eventChannel, END } from \"redux-saga\";\nimport encoding from \"text-encoding\";\n\nimport { upbitmarket } from \"../Api/api\";\n\nimport { coinReadDataUtils } from \"./utils\";\n\nimport axios from \"axios\";\nimport { binancecoinApi } from \"../Api/api\";\nimport { conforms } from \"lodash\";\n\nconst createRequestSaga = (type, api, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        var res;\n\n        if (type === \"GET_UPBIT_MARKET_PRICE_INIT\") {\n\n            const state = yield select();\n            var coinString;\n            Object.keys(state.Coin.upbitTotalNames.data).map((coin) => {\n                coinString += coin + \",\"\n            });\n\n            coinString = coinString.slice(9, -1);\n\n            res = yield call(() => axios.get(`https://api.upbit.com/v1/ticker?markets=${coinString}`), action.payload);\n        }\n        else {\n            res = yield call(api, action.payload);\n        }\n        try {\n            const state = yield select();\n            if (type === \"GET_UPBIT_MARKET_NAMES\" || type === \"GET_UPBIT_MARKET_PRICE_INIT\" || type === \"GET_BINANCE_MARKET_NAMES\") {\n                yield put({ type: SUCCESS, payload: dataMaker(res.data, state) });\n            }\n            else if (type === \"GET_BITHUMB_MARKET_KRW_NAMES\" || type === \"GET_BITHUMB_MARKET_BTC_NAMES\") {\n\n                yield put({ type: SUCCESS, payload: dataMaker(res.data.data, state) });\n            } else if (type === 'GET_KUCOIN_MARKET_NAMES') {\n                yield put({ type: SUCCESS, payload: dataMaker(res.data.data, state) });\n            }\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\nconst createInitRequestSaga = (type, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        try {\n            const state = yield select();\n            yield put({ type: SUCCESS, payload: dataMaker(action.payload, state) });\n\n        } catch (e) {\n            yield put({ type: ERROR, payload: e });\n            throw e;\n        }\n    };\n};\n\n\nconst requestActions = (type, key) => {\n    const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n\n    return (state, action) => {\n        switch (action.type) {\n            case SUCCESS:\n                return reducerUtils.success(state, action.payload, key);\n            case ERROR:\n                return reducerUtils.error(state, action.payload, key);\n            default:\n                return state;\n        }\n    };\n};\n\nconst reducerUtils = {\n    success: (state, payload, key) => {\n        return {\n            ...state,\n            [key]: {\n                data: payload,\n                error: false,\n            },\n        };\n    },\n    error: (state, error, key) => ({\n        ...state,\n        [key]: {\n            ...state[key],\n            error: error,\n        },\n    }),\n};\n\nconst createUpbitSocket = () => {\n    const client = new W3CWebSocket(\"wss://api.upbit.com/websocket/v1\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\nconst createBithumbSocket = () => {\n    const client = new W3CWebSocket(\"wss://pubwss.bithumb.com/pub/ws\");\n    client.binaryType = \"arraybuffer\";\n\n    return client;\n};\n\n\n// 소켓 연결용\nconst connectSocekt = (socket, connectType, type, action, buffer) => {\n    //console.log(\"action\", action);\n    return eventChannel((emit) => {\n        socket.onopen = () => {\n            socket.send(\n                JSON.stringify([\n                    { ticket: \"coinbread-clone\" },\n                    { type: connectType, codes: action },\n                ])\n            );\n        };\n        socket.onmessage = (evt) => {\n            const enc = new encoding.TextDecoder(\"utf-8\");\n            const data = JSON.parse(enc.decode(evt.data));\n            emit(data);\n        };\n\n        socket.onerror = (evt) => {\n            console.log(\"error\", evt);\n            emit(evt);\n            emit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst bitconnectSocekt = (socket, connectType, type, action, buffer) => {\n    return eventChannel((eemit) => {\n        socket.onopen = () => {\n            socket.send(\n                JSON.stringify(\n                    { type: connectType, symbols: action, tickTypes: [\"MID\"] }\n                )\n            );\n        };\n        socket.onmessage = (evt) => {\n            //console.log(evt.data);\n            const data = JSON.parse(evt.data)\n            if (data && data['type'] === 'ticker') {\n                eemit(data['content']);\n            }\n\n        };\n\n        socket.onerror = (evt) => {\n            console.log(\"error\", evt);\n            eemit(evt);\n            eemit(END);\n        };\n\n        const unsubscribe = () => {\n            socket.close();\n        };\n\n        return unsubscribe;\n    }, buffer || buffers.none());\n};\n\nconst createConnectSocketSaga = (type, connectType, dataMaker) => {\n    const SUCCESS = `${type}_SUCCESS`;\n    const ERROR = `${type}_ERROR`;\n\n    return function* (action = {}) {\n        const state = yield select();\n\n        const upbitTotalNames = Object.keys(state.Coin.upbitTotalNames.data);\n        const bithumbTotalNames = Object.keys(state.Coin.bithumbTotalNames.data);\n\n        var client;\n        var bitclient;\n        var clientChannel;\n        //✅ new\n        var bitclientChannel;\n\n        client = yield call(createUpbitSocket);\n\n        bitclient = yield call(createBithumbSocket);\n\n        clientChannel = yield call(\n            connectSocekt,\n            client,\n            connectType,\n            type,\n            upbitTotalNames,\n            buffers.expanding(500)\n        );\n\n        //✅ new\n        bitclientChannel = yield call(\n            bitconnectSocekt,\n            bitclient,\n            connectType,\n            type,\n            bithumbTotalNames,\n            buffers.expanding(500)\n        );\n\n        try {\n            while (true) {\n                const datas = yield flush(clientChannel); // 버퍼 데이터 가져오기\n                const bitdatas = yield flush(bitclientChannel);\n\n                var sortedDATA;\n                var sortedData;\n\n                if (datas.length) {\n                    //console.log(datas);\n                    var sortedObj = {};\n                    datas.forEach((data) => {\n                        if (sortedObj[data.code]) {\n                            // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                            sortedObj[data.code] =\n                                sortedObj[data.code].timestamp > data.timestamp\n                                    ? sortedObj[data.code]\n                                    : data;\n                        } else {\n                            sortedObj[data.code] = data;\n                        }\n                        sortedObj[data.code] = data;\n                    });\n\n                    sortedDATA = Object.keys(sortedObj).map(\n                        (data) => sortedObj[data]\n                    );\n\n                    if (bitdatas.length) {\n                        var sortedObj = {};\n                        var binanceObj;\n\n                        bitdatas.forEach((data) => {\n                            if (sortedObj[data.code]) {\n                                // 버퍼에 있는 데이터중 시간이 가장 최근인 데이터만 남김\n                                sortedObj[data.symbol] =\n                                    sortedObj[data.symbol].time > data.time\n                                        ? sortedObj[data.symbol]\n                                        : data;\n                            } else {\n                                sortedObj[data.symbol] = data;\n                            }\n                            sortedObj[data.symbol] = data;\n                        });\n                        sortedData = Object.keys(sortedObj).map(\n                            (data) => sortedObj[data]\n                        );\n                        binanceObj = yield call(binancecoinApi.getMarketCodes)\n\n                        yield put({ type: SUCCESS, payload: coinReadDataUtils.mixExchangeUpdates(sortedDATA, sortedData, binanceObj.data, state) });\n                    }\n                }\n\n                yield delay(2000); // 500ms 동안 대기\n\n                //✅ Server send\n                /*\n                                const TOPmarketString = state.Coin.TOPmarketString;\n                                var readData = \"\";\n                                TOPmarketString.map((read) => {\n                                    readData = read.ALL;\n                                })\n                \n                                axios.post('https://tradingviewslackshin.herokuapp.com/webhook', JSON.stringify({ arbitrage: readData }), {\n                                    headers: {\n                                        \"Content-Type\": `application/json`,\n                                    },\n                                });*/\n\n            }\n        } catch (e) {\n            console.log(e);\n            yield put({ type: ERROR, payload: e });\n        } finally {\n            clientChannel.close();\n        }\n    };\n};\nexport {\n    createRequestSaga,\n    requestActions,\n    createConnectSocketSaga,\n    createInitRequestSaga,\n}","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/Lib/utils.js",["236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251"],"\nimport axios from \"axios\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\n\nconst pricereturnFloat = (price) => {\n    let data = parseFloat(price);\n    if (data < 1.0) {\n        return data.toFixed(8);\n    }\n    else {\n        return data.toFixed(1);\n    }\n}\n\nconst coinListDataUtils = {\n    kucoinAllNames: (names) => {\n        names.forEach(coinlist => {\n            var coinName = coinlist.symbol.split('-')[0];\n            var type = coinlist.symbol.split('-')[1];\n\n            var newCoin = false;\n            if (type !== 'ETH') {\n                CoinMarketData.find((name) => {\n                    if (name.symbol === coinName) {\n                        newCoin = true;\n                    }\n                });\n                /*if (newCoin === false) {\n                    console.log(coinName, type);\n                }*/\n            }\n        });\n    },\n\n    upbitAllNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            data[name.market] = {\n                korean: name.korean_name,\n            };\n        })\n        return data;\n    },\n    upbitPriceNames: (names, state) => {\n        const coinStateDatas = state.Coin.upbitTotalNames.data;\n        names.forEach(name => {\n            coinStateDatas[name.market] = {\n                korean: pricereturnFloat(name.trade_price),\n            };\n        })\n        return coinStateDatas;\n    },\n\n    binanceNames: (names) => {\n        const data = {};\n        names.forEach(name => {\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                data[name.symbol] = {\n                    korean: name.price\n                };\n            }\n        })\n        return data;\n    },\n    bithumbKRWNames: (names) => {\n        const data = {};\n        Object.keys(names).forEach(name => {\n            data[name + \"_KRW\"] = {\n                korean: pricereturnFloat(names[name].closing_price),\n            };\n        })\n        return data;\n    },\n    bithumbBTCNames: (names, state) => {\n        const coinStateDatas = state.Coin.bithumbTotalNames.data;\n        Object.keys(names).forEach(name => {\n            coinStateDatas[name + \"_BTC\"] = {\n                korean: pricereturnFloat(names[name].closing_price),\n            };\n        })\n        return coinStateDatas;\n    }\n};\n\nconst coinReadDataUtils = {\n    mixExchangeUpdates: (one_names, two_names, three_names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n        const TOPmarketNames = state.Coin.TOPmarketNames;\n        const TOPmarketString = state.Coin.TOPmarketString;\n        //✅ bithumb\n        two_names.forEach(name => {\n            let shortSym = name.symbol.split(\"_\")[0];\n            let moneySym = name.symbol.split(\"_\")[1];\n            let nowPrice = pricereturnFloat(name.closePrice);\n            var sortOrder = [];\n            var cal, calper;\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === \"KRW\") {\n\n                if (sortOrder[0] === 'upbitSym') {\n                    calper = ((nowPrice - parseFloat(coinStateDatas[shortSym].upbitPrice)) / nowPrice * 100).toFixed(2)\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: nowPrice,\n                    bithumbKRW_start_per: calper\n                }\n\n            }\n            else if (moneySym === \"BTC\") {\n\n                var origin = parseFloat(coinStateDatas['BTC'].bithumbPrice);\n                cal = (origin * parseFloat(nowPrice)).toFixed(2);\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: nowPrice,\n                    calKobithumbBTC: cal\n                }\n            }\n        });\n        //✅ upbit\n        one_names.forEach(name => {\n            let shortSym = name.code.split(\"-\")[1];\n            let moneySym = name.code.split(\"-\")[0];\n            let nowPrice = pricereturnFloat(name.trade_price);\n            var sortOrder = [];\n            var cal, calper;\n\n            if (coinStateDatas[shortSym]) {\n                Object.keys(coinStateDatas[shortSym]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0] && !sortOrder[1]) {\n                    sortOrder.splice(0, 2);\n                }\n                else if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitPrice: nowPrice\n                }\n            } else if (moneySym === \"USDT\") {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2)\n                } else if (sortOrder[0] === 'upbitUSDT') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else if (sortOrder[1] === 'upbitBTC') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].calKoupbitBTC)) / cal * 100).toFixed(2)\n                } else {\n                    calper = \"Prepare\";\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitUSDTPrice: nowPrice,\n\n                    upbitUSDT_start_per: calper,\n                    calKoupbitUSDT: cal\n                }\n            } else if (moneySym === \"BTC\") {\n                var origin = parseFloat(coinStateDatas['BTC'].upbitPrice);\n                cal = (origin * parseFloat(nowPrice)).toFixed(2);\n\n                if (sortOrder[0] === 'upbitBTC') {\n                    calper = 'prepare';\n\n                } else if (sortOrder[0] === 'upbitSym') {\n                    calper = ((cal - parseFloat(coinStateDatas[shortSym].upbitPrice)) / cal * 100).toFixed(2);\n                }\n\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    upbitBTCPrice: nowPrice,\n                    //!\n                    calKoupbitBTC: cal,\n                    upbitBTC_start_per: calper\n                }\n            }\n\n            if (coinStateDatas['BTC'].upbitPrice) {\n                //@\n                var upbitusdtkrw = (coinStateDatas['BTC'].upbitPrice / coinStateDatas['BTC'].upbitUSDTPrice).toFixed(1);\n\n                coinStateDatas['USDT'] = {\n                    ...coinStateDatas['USDT'],\n\n                    upbitUSDT: 'USDTKRW',\n                    upbitUSDTPrice: upbitusdtkrw\n                }\n            }\n        });\n\n\n        //✅ binance\n        three_names.forEach(name => {\n            let nowPrice = pricereturnFloat(name.price);\n            var sortOrder = [];\n            var len, cal, calper, coin;\n            let moneySym;\n            let exceptionArr = ['VENUSDT', 'VENBTC', , 'MBLBTC',\n                'TUSDBTC', 'DAIBTC', 'REPBUSD', 'STORJBUSD', 'DENTBTC', 'MFTBTC',\n                'SUNBTC', 'BTTBTC', 'COCOSBTC', 'PAXBTC', 'PAXUSDT', 'PAXBUSD',\n                'BCHSVBTC', 'BCHSVUSDT', 'BCCBTC', 'BCCUSDT', 'HOTBTC', 'BCHABCBTC',\n                'BCHABCUSDT', 'BCHABCBUSD', 'STORMBTC', 'STORMUSDT', 'LENDBTC', 'LENDUSDT', 'LENDBUSD',\n                'ERDBTC', 'ERDUSDT', 'ERDBUSD', 'MCOBTC', 'MCOUSDT', 'STRATBTC', 'STRATUSDT', 'STRATBUSD',\n                'VTHOBUSD', 'DCRBUSD', 'NPXSBTC', 'NPXSUSDT', 'BLZBUSD', 'WNXMBUSD', 'AIONBUSD', 'KMDBUSD',\n                'XZCBT', 'XZCUSDT', 'IRISBUSD', 'HCBTC', 'HCUSDT', 'KEYBTC', 'KEYUSDT', 'TROYBTC', 'SUSDBTC',\n                'TRUBUSD', 'BOOTBTC', 'BOTBUSD', 'PXGBUSD', 'BTSBUSD', 'RENBTCBTC', 'RENBTCETH'\n            ];\n            let exceptionflag = false;\n            exceptionArr.map((symbolName) => {\n                if (name.symbol === symbolName) {\n                    exceptionflag = true\n                    return;\n                }\n            })\n            if (exceptionflag === true)\n                return coinStateDatas;\n\n            if (name.symbol.lastIndexOf('BTC') !== -1) {\n                len = name.symbol.indexOf('BTC');\n                moneySym = 'BTC';\n            } else if (name.symbol.lastIndexOf('USDT') !== -1) {\n                len = name.symbol.indexOf('USDT');\n                moneySym = 'USDT';\n            } else if (name.symbol.lastIndexOf('BUSD') !== -1) {\n                len = name.symbol.indexOf('BUSD');\n                moneySym = 'BUSD';\n            }\n            coin = name.symbol.slice(0, len);\n\n            if (coinStateDatas[coin]) {\n                Object.keys(coinStateDatas[coin]).filter((list) => {\n                    if (list === 'upbitSym') {\n                        sortOrder[0] = 'upbitSym';\n                        return sortOrder;\n                    } else if (list === 'upbitUSDT') {\n                        sortOrder[1] = 'upbitUSDT';\n                        return sortOrder;\n                    }\n                    else if (list === 'upbitBTC') {\n                        sortOrder[2] = 'upbitBTC';\n                        return sortOrder;\n                    }\n                })\n                if (!sortOrder[0] && !sortOrder[1]) {\n                    sortOrder.splice(0, 2);\n                }\n                else if (!sortOrder[0]) {\n                    sortOrder.splice(0, 1);\n                }\n                else if (!sortOrder[1]) {\n                    sortOrder.splice(1, 1);\n                }\n            }\n\n            if (moneySym === 'BTC') {\n                cal = (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(nowPrice)).toFixed(1)\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBTCSym: name.symbol,\n                        binanBTCPrice: nowPrice,\n                        calKobinanBTC: cal,\n                        binBTC_start_per: calper\n                    }\n                }\n            } else if (moneySym === 'USDT') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanUSDTSym: name.symbol,\n                        binanUSDTPrice: nowPrice,\n                        calKoUSDT: cal,\n                        binUSDT_start_per: calper,\n                    }\n                }\n            } else if (moneySym === 'BUSD') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1);\n\n                if (sortOrder[0] === 'upbitBTC')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitBTC)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === \"upbitUSDT\")\n                    calper = ((cal - parseFloat(coinStateDatas[coin].calKoupbitUSDT)) / cal * 100).toFixed(2)\n                else if (sortOrder[0] === 'upbitSym')\n                    calper = ((cal - parseFloat(coinStateDatas[coin].upbitPrice)) / cal * 100).toFixed(2)\n\n                if (coin !== \"\") {\n                    coinStateDatas[coin] = {\n                        ...coinStateDatas[coin],\n                        binanBNBSym: name.symbol,\n                        binanBNBPrice: nowPrice,\n                        calKoBUSD: cal,\n                        binBUSD_start_per: calper,\n                    }\n                }\n            }\n            //📌 EXCEPTION\n            if (name.symbol === 'BTCBUSD') {\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanBNBSym: name.symbol,\n                    binanBNBPrice: nowPrice\n                }\n            } else if (name.symbol === 'BTCUSDT') {\n                cal = (parseFloat(coinStateDatas['USDT'].upbitUSDTPrice) * parseFloat(nowPrice)).toFixed(1)\n                coinStateDatas['BTC'] = {\n                    ...coinStateDatas['BTC'],\n                    binanUSDTSym: name.symbol,\n                    binanUSDTPrice: nowPrice,\n                    calKoUSDT: cal,\n                    per: ((cal - parseFloat(coinStateDatas['BTC'].upbitPrice)) / cal * 100).toFixed(2)\n                }\n            }\n        });\n\n        //✅ Max per search\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n            var maxPer = 0.0;\n            var minPer = 0.0;\n            keyread.forEach((name) => {\n                var per;\n                if (name === 'bithumbKRW_start_per') {\n                    per = parseFloat(coinStateDatas[coin].bithumbKRW_start_per);\n                }\n                else if (name === 'binBUSD_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBUSD_start_per);\n                } else if (name === 'upbitBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitBTC_start_per);\n                } else if (name === 'upbitUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].upbitUSDT_start_per);\n                } else if (name === 'BTCper') {\n                    per = parseFloat(coinStateDatas[coin].BTCper);\n                } else if (name === 'binUSDT_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binUSDT_start_per);\n                }\n                else if (name === 'binBTC_start_per') {\n                    per = parseFloat(coinStateDatas[coin].binBTC_start_per);\n                }\n                if (per > maxPer) {\n                    maxPer = per;\n                }\n                if (per < minPer) {\n                    minPer = per;\n                }\n            })\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                totalPer: maxPer,\n                totalminPer: minPer\n            }\n        });\n\n        //📦 v2\n        Object.keys(coinStateDatas).forEach((coin) => {\n            var read = coinStateDatas[coin];\n            var keyread = Object.keys(read);\n            var maxPer = 0.0;\n            var minPer = Number.MAX_SAFE_INTEGER;\n            var sortExchange = [];\n            var exchange;\n            var lastminExchange, lastmaxExchange;\n            var minmaxExchange, maxExchange, minExchange;\n\n            keyread.forEach((name) => {\n                var price;\n                if (name === 'upbitPrice') {\n                    price = parseFloat(coinStateDatas[coin].upbitPrice);\n                    sortExchange.push('upbit');\n                    exchange = 'upbitWithdraw';\n                    minmaxExchange = 'upbitKRW';\n                }\n                else if (name === 'bithumbPrice') {\n                    price = parseFloat(coinStateDatas[coin].bithumbPrice);\n                    sortExchange.push('bithumb');\n                    exchange = 'bithumbWithdraw';\n                    minmaxExchange = 'bithumbKRW';\n                }\n                else if (name === 'calKoupbitBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitBTC);\n                    sortExchange.push('upbit');\n                    exchange = 'upbitWithdraw';\n                    minmaxExchange = 'upbitBTC';\n                }\n                else if (name === 'calKobithumbBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKobithumbBTC);\n                    //ok\n                    sortExchange.push('bithumb');\n                    exchange = 'bithumbWithdraw';\n                    minmaxExchange = 'bithumbBTC';\n                } else if (name === 'calKobinanBTC') {\n                    price = parseFloat(coinStateDatas[coin].calKobinanBTC);\n                    sortExchange.push('binance');\n                    exchange = 'binanceWithdraw';\n                    minmaxExchange = 'binanceBTC';\n                } else if (name === 'calKoupbitUSDT') {\n                    price = parseFloat(coinStateDatas[coin].calKoupbitUSDT);\n                    sortExchange.push('upbit');\n                    minmaxExchange = 'upbitUSDT';\n                } else if (name === 'calKoUSDT') {\n                    price = parseFloat(coinStateDatas[coin].calKoUSDT);\n                    sortExchange.push('binance');\n                    exchange = 'binanceWithdraw';\n                    minmaxExchange = 'binanceUSDT';\n                } else if (name === 'calKoBUSD') {\n                    price = parseFloat(coinStateDatas[coin].calKoBUSD);\n                    sortExchange.push('binance');\n                    exchange = 'binanceWithdraw';\n                    minmaxExchange = 'binanceBUSD';\n                }\n\n                if (price > maxPer) {\n                    maxPer = price;\n                    maxExchange = minmaxExchange\n                    lastmaxExchange = exchange;\n                }\n                if (price < minPer) {\n                    minPer = price;\n                    minExchange = minmaxExchange\n                    lastminExchange = exchange;\n                }\n            })\n            sortExchange = Array.from(new Set(sortExchange));\n\n            if (coin === 'MKR') {\n                console.log('MKR price check', minPer, maxPer, coinStateDatas['MKR']);\n            }\n\n\n            var result = 0.0;\n            if (sortExchange.length <= 1) {\n                minPer = 0;\n                maxPer = 0;\n                result = 0;\n            }\n            else {\n                CoinMarketData.find((name) => {\n                    if (name.symbol === coin) {\n                        if (lastminExchange === 'bithumbWithdraw' && lastmaxExchange === 'bithumbWithdraw') {\n                            minPer = 0;\n                            maxPer = 0;\n                            result = 0;\n                            return;\n                        }\n                        else if (lastminExchange === 'upbitWithdraw') {\n                            if (name.upbitWithdraw !== 'NO')\n                                minPer = (parseFloat(name.upbitWithdraw) * parseFloat(minPer)) + minPer;\n                            else {\n                                minPer = 0;\n                                maxPer = 0;\n                                result = 0;\n                                return;\n                            }\n                        } else if (lastminExchange === 'bithumbWithdraw') {\n                            minPer = (parseFloat(name.bithumbWithdraw) * parseFloat(minPer)) + minPer;\n                        }\n                        else if (lastminExchange === 'binanceWithdraw') {\n                            if (name.upbitWithdraw !== 'NO')\n                                minPer = (parseFloat(name.binanceWithdraw) * parseFloat(minPer)) + minPer;\n                            else {\n                                minPer = 0;\n                                maxPer = 0;\n                                result = 0;\n                                return;\n                            }\n                        }\n                    }\n                })\n                if (!(minPer <= 0 || maxPer === 0))\n                    result = ((maxPer - minPer) / minPer * 100).toFixed(1);\n                else {\n                    result = 0;\n                }\n            }\n            coinStateDatas[coin] = {\n                ...coinStateDatas[coin],\n                testper: result,\n                symbol: coin,\n                minExchange: minExchange,\n                maxExchange: maxExchange,\n            }\n        });\n\n        //!\n        TOPmarketNames.splice(0);\n        var coinStateCount = 0;\n        var coinStringMake = \"\";\n        Object.keys(coinStateDatas).forEach((coinOne) => {\n            if (coinStateDatas[coinOne].testper > 0) {\n                coinStringMake += coinOne + \",\";\n                var dataFactory = [];\n                var keyread = Object.keys(coinStateDatas[coinOne])\n                var arrCount = 0;\n                keyread.forEach((name) => {\n                    if (name === 'upbitPrice') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].upbitSym,\n                            'exchange': 'upbit',\n                            'OriginPrice': coinStateDatas[coinOne].upbitPrice,\n                            'KrwPrice': coinStateDatas[coinOne].upbitPrice\n\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'bithumbSym') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].bithumbSym,\n                            'exchange': 'bithumb',\n                            'OriginPrice': coinStateDatas[coinOne].bithumbPrice,\n                            'KrwPrice': coinStateDatas[coinOne].bithumbPrice\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoupbitBTC') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].upbitBTC,\n                            'exchange': 'upbit',\n                            'OriginPrice': coinStateDatas[coinOne].upbitBTCPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoupbitBTC\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKobithumbBTC') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].bithumbBTC,\n                            'exchange': 'bithumb',\n                            'OriginPrice': coinStateDatas[coinOne].bithumbBTCPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKobithumbBTC\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoupbitUSDT') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].upbitUSDT,\n                            'exchange': 'upbit',\n                            'OriginPrice': coinStateDatas[coinOne].upbitUSDTPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoupbitUSDT\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKobinanBTC') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].binanBTCSym,\n                            'exchange': 'binance',\n                            'OriginPrice': coinStateDatas[coinOne].binanBTCPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKobinanBTC\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoUSDT') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].binanUSDTSym,\n                            'exchange': 'binance',\n                            'OriginPrice': coinStateDatas[coinOne].binanUSDTPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoUSDT\n                        }\n                        arrCount++;\n                    }\n                    else if (name === 'calKoBUSD') {\n                        dataFactory[arrCount] = {\n                            'MainSym': coinOne,\n                            'sym': coinStateDatas[coinOne].binanBNBSym,\n                            'exchange': 'binance',\n                            'OriginPrice': coinStateDatas[coinOne].binanBNBPrice,\n                            'KrwPrice': coinStateDatas[coinOne].calKoBUSD\n                        }\n                        arrCount++;\n                    }\n\n                });\n                //console.log('before', dataFactory); //1 2 3 4 5 \n                dataFactory = dataFactory.sort((next, prev) => {\n\n                    if (parseFloat(next.KrwPrice) > parseFloat(prev.KrwPrice)) {\n                        return -1;\n                    } else {\n                        return 0;\n                    }\n                })\n\n                TOPmarketNames[coinStateCount] = dataFactory;//coinStateDatas[coinOne]\n                coinStateCount++;\n            }\n        })\n        TOPmarketString[0] = { 'ALL': coinStringMake }\n\n        return coinStateDatas;\n    },\n    //\n    upbitInitNames: (names, state) => {\n\n        var stringdd = \"\";\n        CoinMarketData.find((name) => {\n            stringdd += name.symbol + \" \"\n        });\n        const data = {};\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n\n            if (shortSym === \"BTC\" && moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                }\n            } else if (shortSym === \"BTC\" && moneySym === \"USDT\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                }\n            }\n        })\n        data['USDT'] = {\n            ...data['USDT'],\n            upbitUSDTPrice: (data['BTC'].upbitPrice / data['BTC'].upbitUSDTPrice).toFixed(1),\n            upbitUSDT: 'USDTKRW',\n        }\n\n        Object.keys(names).forEach(name => {\n\n            let shortSym = name.split(\"-\")[1];\n            let moneySym = name.split(\"-\")[0];\n            let imgsrc = \"\";\n            CoinMarketData.find((coin) => {\n                if (coin.symbol === shortSym) {\n                    imgsrc = coin.imgsrc;\n                }\n            })\n            if (moneySym === \"KRW\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitPrice: names[name].korean,\n                    upbitSym: name,\n                    imgsrc: imgsrc\n                }\n            } else if (moneySym === \"USDT\") {\n\n\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitUSDTPrice: names[name].korean,\n                    upbitUSDT: name,\n                    imgsrc: imgsrc,\n                    calKoupbitUSDT: (parseFloat(data['USDT'].upbitUSDTPrice) * parseFloat(names[name].korean)).toFixed(1)\n                }\n            } else if (moneySym === \"BTC\") {\n                data[shortSym] = {\n                    ...data[shortSym],\n                    upbitBTCPrice: names[name].korean,\n                    upbitBTC: name,\n                    imgsrc: imgsrc,\n                    calKoupbitBTC: (parseFloat(data['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        });\n        return data;\n    },\n    bithumbInitNames: (names, state) => {\n        const coinStateDatas = state.Coin.marketNames.data;\n\n        Object.keys(names).forEach(name => {\n            let shortSym = name.split(\"_\")[0];\n            let moneySym = name.split(\"_\")[1];\n\n            if (moneySym === \"KRW\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbPrice: names[name].korean,\n                    bithumbSym: name,\n                }\n            } else if (moneySym === \"BTC\") {\n                coinStateDatas[shortSym] = {\n                    ...coinStateDatas[shortSym],\n                    bithumbBTCPrice: names[name].korean,\n                    bithumbBTC: name,\n                    calKobithumbBTC: (parseFloat(coinStateDatas['BTC'].upbitPrice) * parseFloat(names[name].korean)).toFixed(2)\n                }\n            }\n        })\n\n\n        //!\n\n\n        return coinStateDatas;\n    }\n};\n\n\nexport {\n    coinListDataUtils,\n    coinReadDataUtils\n}","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/components/CoinList.js",["252","253","254"],"import React from 'react';\nimport { useSelector } from 'react-redux';\n\nimport \"../components/CoinList.css\";\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\nimport Coinone from \"../components/Coinone\";\n\nfunction CoinList({ one_coin }) {\n    var coinMarket = useSelector((state) => state.Coin.marketNames.data);\n    var symimg;\n    CoinMarketData.find((coinchk) => {\n        if (coinchk.symbol === one_coin[0].MainSym) {\n            symimg = coinchk.imgsrc;\n            return;\n        }\n    })\n\n    /*\n        var Priceplus = \"\";\n        if (one_coin.binUSDT_start_per > 0) {\n            Priceplus = \"BINplus-per\";\n        } else {\n            Priceplus = \"BINminus-per\";\n        }*/\n    /*\n        var exchangeimg = \"\";\n        if (one_coin.exchange === 'upbit')\n            exchangeimg = CoinMarketData[0].imgsrc;\n        else if (one_coin.exchange === 'bithumb')\n            exchangeimg = CoinMarketData[1].imgsrc;\n        else if (one_coin.exchange === 'binance')\n            exchangeimg = CoinMarketData[2].imgsrc;\n    */\n\n\n    return (\n        <div className='coin-container'>\n            <div className=\"coin-row\" >\n                <div className='coin'>\n                    <img src={symimg} />\n                    <h1 classame=\"coin-data\" >{one_coin[0].MainSym}\n\n                        <div>{coinMarket[one_coin[0].MainSym].minExchange}</div>\n                        <div>\n                            ↓\n                        </div>\n                        <div>{coinMarket[one_coin[0].MainSym].maxExchange}</div>\n\n                    </h1>\n\n\n                </div>\n\n                <div>{coinMarket[one_coin[0].MainSym].testper}</div>\n                {\n                    one_coin.map((one) => {\n                        return <Coinone key={`one_sym_${one.sym}`} oneCoin={one} />\n                    })\n                }\n\n            </div>\n\n        </div>\n    )\n}\n\nexport default CoinList;\n/*\n\n<div className='coin-container'>\n            <div className=\"coin-row\" >\n                <div className='coin'>\n                    <img src={symimg} />\n                    <h1>{one_coin_Sym}</h1>\n                </div>\n\n                <img className=\"exchange-img\" src={exchangeimg} />\n\n                <div className=\"coin-data coin-pair-one\">\n\n                    <p className=\"coin-price\">\n                        KRW-{one_coin.KrwPrice}\n                    </p>\n\n\n                    <p className=\"coin-price\">\n                        {one_coin.OriginPrice}\n                    </p>\n\n                </div>\n            </div>\n        </div>\n\n*/\n\n\n/*\n\n\n*/","/Users/sinhyeonsu/Documents/coingetprice_ver2.0/src/components/Coinone.js",["255","256","257","258"],"import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport CoinMarketData from \"../Api/CoinMarketData.json\";\nimport \"../components/CoinList.css\";\n\nfunction Coinone({ oneCoin }) {\n    var exchangeImg = \"\";\n    if (oneCoin.exchange === 'upbit') {\n        exchangeImg = CoinMarketData[0].imgsrc;\n    } else if (oneCoin.exchange === 'bithumb') {\n        exchangeImg = CoinMarketData[1].imgsrc;\n    } else if (oneCoin.exchange === 'binance') {\n        exchangeImg = CoinMarketData[2].imgsrc;\n    }\n\n    return (\n        <>\n            <img className=\"exchange-img\" src={exchangeImg} />\n\n            <div className=\"coin-data\" >\n                <p>\n                    {oneCoin.sym}\n                </p>\n                <p>\n                    KRW-{oneCoin.KrwPrice}\n                </p>\n                <p>\n                    {oneCoin.OriginPrice}\n                </p>\n            </div>\n        </>\n    )\n}\n\n\nexport default Coinone;",{"ruleId":"259","replacedBy":"260"},{"ruleId":"261","replacedBy":"262"},{"ruleId":"263","severity":1,"message":"264","line":2,"column":10,"nodeType":"265","messageId":"266","endLine":2,"endColumn":21},{"ruleId":"263","severity":1,"message":"267","line":3,"column":8,"nodeType":"265","messageId":"266","endLine":3,"endColumn":21},{"ruleId":"263","severity":1,"message":"268","line":4,"column":21,"nodeType":"265","messageId":"266","endLine":4,"endColumn":38},{"ruleId":"263","severity":1,"message":"269","line":4,"column":40,"nodeType":"265","messageId":"266","endLine":4,"endColumn":54},{"ruleId":"263","severity":1,"message":"270","line":8,"column":27,"nodeType":"265","messageId":"266","endLine":8,"endColumn":33},{"ruleId":"263","severity":1,"message":"271","line":8,"column":69,"nodeType":"265","messageId":"266","endLine":8,"endColumn":75},{"ruleId":"272","severity":1,"message":"273","line":21,"column":13,"nodeType":"274","endLine":69,"endColumn":4},{"ruleId":"263","severity":1,"message":"275","line":26,"column":15,"nodeType":"265","messageId":"266","endLine":26,"endColumn":26},{"ruleId":"263","severity":1,"message":"276","line":2,"column":8,"nodeType":"265","messageId":"266","endLine":2,"endColumn":13},{"ruleId":"263","severity":1,"message":"277","line":3,"column":21,"nodeType":"265","messageId":"266","endLine":3,"endColumn":25},{"ruleId":"263","severity":1,"message":"278","line":3,"column":27,"nodeType":"265","messageId":"266","endLine":3,"endColumn":30},{"ruleId":"263","severity":1,"message":"279","line":3,"column":40,"nodeType":"265","messageId":"266","endLine":3,"endColumn":45},{"ruleId":"263","severity":1,"message":"280","line":3,"column":47,"nodeType":"265","messageId":"266","endLine":3,"endColumn":52},{"ruleId":"263","severity":1,"message":"281","line":5,"column":93,"nodeType":"265","messageId":"266","endLine":5,"endColumn":118},{"ruleId":"263","severity":1,"message":"282","line":32,"column":7,"nodeType":"265","messageId":"266","endLine":32,"endColumn":37},{"ruleId":"263","severity":1,"message":"283","line":33,"column":7,"nodeType":"265","messageId":"266","endLine":33,"endColumn":35},{"ruleId":"263","severity":1,"message":"284","line":87,"column":7,"nodeType":"265","messageId":"266","endLine":87,"endColumn":31},{"ruleId":"285","severity":1,"message":"286","line":19,"column":31,"nodeType":"274","messageId":"287","endLine":19,"endColumn":33},{"ruleId":"263","severity":1,"message":"288","line":1,"column":10,"nodeType":"265","messageId":"266","endLine":1,"endColumn":19},{"ruleId":"263","severity":1,"message":"277","line":1,"column":21,"nodeType":"265","messageId":"266","endLine":1,"endColumn":25},{"ruleId":"263","severity":1,"message":"278","line":1,"column":27,"nodeType":"265","messageId":"266","endLine":1,"endColumn":30},{"ruleId":"263","severity":1,"message":"289","line":1,"column":32,"nodeType":"265","messageId":"266","endLine":1,"endColumn":38},{"ruleId":"263","severity":1,"message":"279","line":1,"column":40,"nodeType":"265","messageId":"266","endLine":1,"endColumn":45},{"ruleId":"263","severity":1,"message":"280","line":1,"column":47,"nodeType":"265","messageId":"266","endLine":1,"endColumn":52},{"ruleId":"263","severity":1,"message":"290","line":2,"column":8,"nodeType":"265","messageId":"266","endLine":2,"endColumn":13},{"ruleId":"263","severity":1,"message":"291","line":4,"column":10,"nodeType":"265","messageId":"266","endLine":4,"endColumn":18},{"ruleId":"263","severity":1,"message":"292","line":4,"column":20,"nodeType":"265","messageId":"266","endLine":4,"endColumn":23},{"ruleId":"285","severity":1,"message":"293","line":208,"column":69,"nodeType":"274","messageId":"294","endLine":208,"endColumn":71},{"ruleId":"285","severity":1,"message":"293","line":273,"column":73,"nodeType":"274","messageId":"294","endLine":273,"endColumn":75},{"ruleId":"295","severity":1,"message":"296","line":297,"column":25,"nodeType":"265","messageId":"297","endLine":297,"endColumn":31},{"ruleId":"295","severity":1,"message":"296","line":299,"column":25,"nodeType":"265","messageId":"297","endLine":299,"endColumn":31},{"ruleId":"295","severity":1,"message":"296","line":301,"column":25,"nodeType":"265","messageId":"297","endLine":301,"endColumn":31},{"ruleId":"295","severity":1,"message":"298","line":315,"column":21,"nodeType":"265","messageId":"297","endLine":315,"endColumn":24},{"ruleId":"285","severity":1,"message":"293","line":319,"column":73,"nodeType":"274","messageId":"294","endLine":319,"endColumn":75},{"ruleId":"295","severity":1,"message":"296","line":344,"column":25,"nodeType":"265","messageId":"297","endLine":344,"endColumn":31},{"ruleId":"295","severity":1,"message":"296","line":347,"column":25,"nodeType":"265","messageId":"297","endLine":347,"endColumn":31},{"ruleId":"285","severity":1,"message":"293","line":401,"column":69,"nodeType":"274","messageId":"294","endLine":401,"endColumn":71},{"ruleId":"295","severity":1,"message":"299","line":445,"column":21,"nodeType":"265","messageId":"297","endLine":445,"endColumn":24},{"ruleId":"295","severity":1,"message":"300","line":447,"column":21,"nodeType":"265","messageId":"297","endLine":447,"endColumn":25},{"ruleId":"295","severity":1,"message":"298","line":448,"column":21,"nodeType":"265","messageId":"297","endLine":448,"endColumn":24},{"ruleId":"295","severity":1,"message":"296","line":450,"column":21,"nodeType":"265","messageId":"297","endLine":450,"endColumn":27},{"ruleId":"285","severity":1,"message":"293","line":452,"column":69,"nodeType":"274","messageId":"294","endLine":452,"endColumn":71},{"ruleId":"295","severity":1,"message":"299","line":496,"column":21,"nodeType":"265","messageId":"297","endLine":496,"endColumn":24},{"ruleId":"295","severity":1,"message":"300","line":497,"column":21,"nodeType":"265","messageId":"297","endLine":497,"endColumn":25},{"ruleId":"295","severity":1,"message":"298","line":499,"column":21,"nodeType":"265","messageId":"297","endLine":499,"endColumn":24},{"ruleId":"295","severity":1,"message":"296","line":501,"column":21,"nodeType":"265","messageId":"297","endLine":501,"endColumn":27},{"ruleId":"285","severity":1,"message":"293","line":503,"column":69,"nodeType":"274","messageId":"294","endLine":503,"endColumn":71},{"ruleId":"295","severity":1,"message":"298","line":558,"column":21,"nodeType":"265","messageId":"297","endLine":558,"endColumn":24},{"ruleId":"285","severity":1,"message":"301","line":652,"column":40,"nodeType":"274","messageId":"287","endLine":652,"endColumn":42},{"ruleId":"263","severity":1,"message":"302","line":6,"column":10,"nodeType":"265","messageId":"266","endLine":6,"endColumn":18},{"ruleId":"263","severity":1,"message":"290","line":9,"column":8,"nodeType":"265","messageId":"266","endLine":9,"endColumn":13},{"ruleId":"263","severity":1,"message":"303","line":10,"column":26,"nodeType":"265","messageId":"266","endLine":10,"endColumn":34},{"ruleId":"263","severity":1,"message":"304","line":10,"column":36,"nodeType":"265","messageId":"266","endLine":10,"endColumn":47},{"ruleId":"285","severity":1,"message":"286","line":23,"column":69,"nodeType":"274","messageId":"287","endLine":23,"endColumn":71},{"ruleId":"263","severity":1,"message":"305","line":28,"column":26,"nodeType":"265","messageId":"266","endLine":28,"endColumn":36},{"ruleId":"263","severity":1,"message":"306","line":169,"column":13,"nodeType":"265","messageId":"266","endLine":169,"endColumn":18},{"ruleId":"307","severity":1,"message":"308","line":271,"column":35,"nodeType":"274","messageId":"309","endLine":283,"endColumn":22},{"ruleId":"307","severity":1,"message":"310","line":286,"column":25,"nodeType":"274","messageId":"309","endLine":286,"endColumn":50},{"ruleId":"295","severity":1,"message":"311","line":291,"column":29,"nodeType":"265","messageId":"297","endLine":291,"endColumn":38},{"ruleId":"263","severity":1,"message":"312","line":293,"column":29,"nodeType":"265","messageId":"266","endLine":293,"endColumn":37},{"ruleId":"307","severity":1,"message":"308","line":295,"column":42,"nodeType":"274","messageId":"309","endLine":308,"endColumn":26},{"ruleId":"307","severity":1,"message":"310","line":310,"column":29,"nodeType":"274","messageId":"309","endLine":310,"endColumn":54},{"ruleId":"263","severity":1,"message":"313","line":338,"column":11,"nodeType":"265","messageId":"266","endLine":338,"endColumn":18},{"ruleId":"263","severity":1,"message":"314","line":339,"column":11,"nodeType":"265","messageId":"266","endLine":339,"endColumn":16},{"ruleId":"263","severity":1,"message":"315","line":2,"column":23,"nodeType":"265","messageId":"266","endLine":2,"endColumn":34},{"ruleId":"316","severity":1,"message":"317","line":8,"column":21,"nodeType":"318","messageId":"319","endLine":8,"endColumn":33},{"ruleId":"263","severity":1,"message":"320","line":13,"column":11,"nodeType":"265","messageId":"266","endLine":13,"endColumn":24},{"ruleId":"263","severity":1,"message":"321","line":14,"column":11,"nodeType":"265","messageId":"266","endLine":14,"endColumn":24},{"ruleId":"322","severity":1,"message":"323","line":38,"column":21,"nodeType":"324","endLine":38,"endColumn":71},{"ruleId":"285","severity":1,"message":"325","line":51,"column":46,"nodeType":"274","messageId":"294","endLine":51,"endColumn":48},{"ruleId":"263","severity":1,"message":"326","line":1,"column":17,"nodeType":"265","messageId":"266","endLine":1,"endColumn":26},{"ruleId":"263","severity":1,"message":"264","line":2,"column":10,"nodeType":"265","messageId":"266","endLine":2,"endColumn":21},{"ruleId":"263","severity":1,"message":"315","line":2,"column":23,"nodeType":"265","messageId":"266","endLine":2,"endColumn":34},{"ruleId":"263","severity":1,"message":"327","line":52,"column":9,"nodeType":"265","messageId":"266","endLine":52,"endColumn":19},{"ruleId":"322","severity":1,"message":"323","line":66,"column":21,"nodeType":"324","endLine":66,"endColumn":50},{"ruleId":"322","severity":1,"message":"323","line":71,"column":38,"nodeType":"324","endLine":71,"endColumn":88},{"ruleId":"322","severity":1,"message":"323","line":91,"column":40,"nodeType":"324","endLine":91,"endColumn":92},{"ruleId":"322","severity":1,"message":"323","line":119,"column":38,"nodeType":"324","endLine":119,"endColumn":88},{"ruleId":"322","severity":1,"message":"323","line":155,"column":40,"nodeType":"324","endLine":155,"endColumn":92},{"ruleId":"322","severity":1,"message":"323","line":175,"column":41,"nodeType":"324","endLine":175,"endColumn":93},{"ruleId":"322","severity":1,"message":"323","line":212,"column":39,"nodeType":"324","endLine":212,"endColumn":89},{"ruleId":"322","severity":1,"message":"323","line":251,"column":42,"nodeType":"324","endLine":251,"endColumn":94},{"ruleId":"322","severity":1,"message":"323","line":291,"column":41,"nodeType":"324","endLine":291,"endColumn":93},{"ruleId":"263","severity":1,"message":"328","line":2,"column":17,"nodeType":"265","messageId":"266","endLine":2,"endColumn":25},{"ruleId":"263","severity":1,"message":"329","line":3,"column":10,"nodeType":"265","messageId":"266","endLine":3,"endColumn":20},{"ruleId":"263","severity":1,"message":"270","line":3,"column":22,"nodeType":"265","messageId":"266","endLine":3,"endColumn":28},{"ruleId":"263","severity":1,"message":"330","line":3,"column":30,"nodeType":"265","messageId":"266","endLine":3,"endColumn":42},{"ruleId":"263","severity":1,"message":"331","line":3,"column":44,"nodeType":"265","messageId":"266","endLine":3,"endColumn":51},{"ruleId":"263","severity":1,"message":"332","line":11,"column":15,"nodeType":"265","messageId":"266","endLine":11,"endColumn":19},{"ruleId":"263","severity":1,"message":"333","line":24,"column":13,"nodeType":"265","messageId":"266","endLine":24,"endColumn":18},{"ruleId":"259","replacedBy":"334"},{"ruleId":"261","replacedBy":"335"},{"ruleId":"263","severity":1,"message":"336","line":11,"column":7,"nodeType":"265","messageId":"266","endLine":11,"endColumn":38},{"ruleId":"263","severity":1,"message":"337","line":12,"column":7,"nodeType":"265","messageId":"266","endLine":12,"endColumn":36},{"ruleId":"263","severity":1,"message":"338","line":12,"column":11,"nodeType":"265","messageId":"266","endLine":12,"endColumn":23},{"ruleId":"322","severity":1,"message":"323","line":38,"column":21,"nodeType":"324","endLine":38,"endColumn":84},{"ruleId":"322","severity":1,"message":"323","line":49,"column":21,"nodeType":"324","endLine":49,"endColumn":84},{"ruleId":"322","severity":1,"message":"323","line":59,"column":21,"nodeType":"324","endLine":59,"endColumn":84},{"ruleId":"322","severity":1,"message":"323","line":70,"column":21,"nodeType":"324","endLine":70,"endColumn":84},{"ruleId":"322","severity":1,"message":"323","line":81,"column":21,"nodeType":"324","endLine":81,"endColumn":84},{"ruleId":"322","severity":1,"message":"323","line":90,"column":21,"nodeType":"324","endLine":90,"endColumn":84},{"ruleId":"263","severity":1,"message":"264","line":2,"column":10,"nodeType":"265","messageId":"266","endLine":2,"endColumn":21},{"ruleId":"263","severity":1,"message":"339","line":3,"column":8,"nodeType":"265","messageId":"266","endLine":3,"endColumn":22},{"ruleId":"263","severity":1,"message":"277","line":4,"column":10,"nodeType":"265","messageId":"266","endLine":4,"endColumn":14},{"ruleId":"263","severity":1,"message":"278","line":4,"column":16,"nodeType":"265","messageId":"266","endLine":4,"endColumn":19},{"ruleId":"263","severity":1,"message":"289","line":4,"column":21,"nodeType":"265","messageId":"266","endLine":4,"endColumn":27},{"ruleId":"263","severity":1,"message":"279","line":4,"column":29,"nodeType":"265","messageId":"266","endLine":4,"endColumn":34},{"ruleId":"263","severity":1,"message":"280","line":4,"column":36,"nodeType":"265","messageId":"266","endLine":4,"endColumn":41},{"ruleId":"263","severity":1,"message":"340","line":5,"column":8,"nodeType":"265","messageId":"266","endLine":5,"endColumn":12},{"ruleId":"263","severity":1,"message":"341","line":6,"column":10,"nodeType":"265","messageId":"266","endLine":6,"endColumn":21},{"ruleId":"263","severity":1,"message":"291","line":12,"column":10,"nodeType":"265","messageId":"266","endLine":12,"endColumn":18},{"ruleId":"285","severity":1,"message":"286","line":25,"column":69,"nodeType":"274","messageId":"287","endLine":25,"endColumn":71},{"ruleId":"307","severity":1,"message":"308","line":233,"column":35,"nodeType":"274","messageId":"309","endLine":244,"endColumn":22},{"ruleId":"307","severity":1,"message":"310","line":247,"column":25,"nodeType":"274","messageId":"309","endLine":247,"endColumn":50},{"ruleId":"295","severity":1,"message":"311","line":251,"column":29,"nodeType":"265","messageId":"297","endLine":251,"endColumn":38},{"ruleId":"307","severity":1,"message":"308","line":254,"column":42,"nodeType":"274","messageId":"309","endLine":265,"endColumn":26},{"ruleId":"307","severity":1,"message":"310","line":267,"column":29,"nodeType":"274","messageId":"309","endLine":267,"endColumn":54},{"ruleId":"263","severity":1,"message":"290","line":2,"column":8,"nodeType":"265","messageId":"266","endLine":2,"endColumn":13},{"ruleId":"263","severity":1,"message":"342","line":21,"column":17,"nodeType":"265","messageId":"266","endLine":21,"endColumn":24},{"ruleId":"285","severity":1,"message":"301","line":23,"column":44,"nodeType":"274","messageId":"287","endLine":23,"endColumn":46},{"ruleId":"285","severity":1,"message":"293","line":107,"column":69,"nodeType":"274","messageId":"294","endLine":107,"endColumn":71},{"ruleId":"285","severity":1,"message":"293","line":161,"column":69,"nodeType":"274","messageId":"294","endLine":161,"endColumn":71},{"ruleId":"343","severity":1,"message":"344","line":251,"column":32,"nodeType":"345","messageId":"346","endLine":260,"endColumn":14},{"ruleId":"285","severity":1,"message":"325","line":262,"column":43,"nodeType":"274","messageId":"294","endLine":262,"endColumn":45},{"ruleId":"285","severity":1,"message":"286","line":265,"column":21,"nodeType":"347","messageId":"348","endLine":265,"endColumn":28},{"ruleId":"285","severity":1,"message":"293","line":284,"column":65,"nodeType":"274","messageId":"294","endLine":284,"endColumn":67},{"ruleId":"285","severity":1,"message":"349","line":507,"column":44,"nodeType":"274","messageId":"294","endLine":507,"endColumn":46},{"ruleId":"285","severity":1,"message":"301","line":513,"column":29,"nodeType":"347","messageId":"348","endLine":513,"endColumn":36},{"ruleId":"285","severity":1,"message":"301","line":522,"column":33,"nodeType":"347","messageId":"348","endLine":522,"endColumn":40},{"ruleId":"285","severity":1,"message":"301","line":534,"column":33,"nodeType":"347","messageId":"348","endLine":534,"endColumn":40},{"ruleId":"263","severity":1,"message":"350","line":669,"column":13,"nodeType":"265","messageId":"266","endLine":669,"endColumn":21},{"ruleId":"285","severity":1,"message":"301","line":670,"column":36,"nodeType":"274","messageId":"287","endLine":670,"endColumn":38},{"ruleId":"285","severity":1,"message":"301","line":703,"column":40,"nodeType":"274","messageId":"287","endLine":703,"endColumn":42},{"ruleId":"285","severity":1,"message":"349","line":11,"column":35,"nodeType":"274","messageId":"294","endLine":11,"endColumn":37},{"ruleId":"285","severity":1,"message":"301","line":14,"column":13,"nodeType":"347","messageId":"348","endLine":14,"endColumn":20},{"ruleId":"322","severity":1,"message":"323","line":40,"column":21,"nodeType":"324","endLine":40,"endColumn":41},{"ruleId":"263","severity":1,"message":"326","line":1,"column":17,"nodeType":"265","messageId":"266","endLine":1,"endColumn":26},{"ruleId":"263","severity":1,"message":"264","line":2,"column":10,"nodeType":"265","messageId":"266","endLine":2,"endColumn":21},{"ruleId":"263","severity":1,"message":"315","line":2,"column":23,"nodeType":"265","messageId":"266","endLine":2,"endColumn":34},{"ruleId":"322","severity":1,"message":"323","line":18,"column":13,"nodeType":"324","endLine":18,"endColumn":63},"no-native-reassign",["351"],"no-negated-in-lhs",["352"],"no-unused-vars","'useSelector' is defined but never used.","Identifier","unusedVar","'CoinContainer' is defined but never used.","'getMarketNameSaga' is defined but never used.","'startInitAsync' is defined but never used.","'addDoc' is defined but never used.","'setDoc' is defined but never used.","react-hooks/exhaustive-deps","Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching","ArrowFunctionExpression","'logdBoolean' is assigned a value but never used.","'React' is defined but never used.","'call' is defined but never used.","'put' is defined but never used.","'flush' is defined but never used.","'delay' is defined but never used.","'connectBithumbSocketThunk' is defined but never used.","'CONNECT_BITHUMB_SOCKET_SUCCESS' is assigned a value but never used.","'CONNECT_BITHUMB_SOCKET_ERROR' is assigned a value but never used.","'connectBithumbSocketSaga' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","expectedInside","'takeEvery' is defined but never used.","'select' is defined but never used.","'axios' is defined but never used.","'conforms' is defined but never used.","'max' is defined but never used.","Array.prototype.filter() expects a value to be returned at the end of arrow function.","expectedAtEnd","no-redeclare","'calper' is already defined.","redeclared","'cal' is already defined.","'len' is already defined.","'coin' is already defined.","Array.prototype.find() expects a return value from arrow function.","'throttle' is defined but never used.","'geckoApi' is defined but never used.","'upbitoinApi' is defined but never used.","'coinString' is assigned a value but never used.","'count' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'sortedObj', 'sortedObj', 'sortedObj', 'sortedObj', 'sortedObj', 'sortedObj'.","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'sortedObj'.","'sortedObj' is already defined.","'geckoObj' is defined but never used.","'SUCCESS' is assigned a value but never used.","'ERROR' is assigned a value but never used.","'useDispatch' is defined but never used.","no-new-object","The object literal notation {} is preferrable.","NewExpression","preferLiteral","'bithumbimgsrc' is assigned a value but never used.","'binanceimgsrc' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","Array.prototype.map() expects a value to be returned at the end of arrow function.","'useEffect' is defined but never used.","'BINUSDplus' is assigned a value but never used.","'useState' is defined but never used.","'collection' is defined but never used.","'getFirestore' is defined but never used.","'getDocs' is defined but never used.","'ipv4' is assigned a value but never used.","'email' is assigned a value but never used.",["351"],["352"],"'GET_KUCOIN_MARKET_NAMES_SUCCESS' is assigned a value but never used.","'GET_KUCOIN_MARKET_NAMES_ERROR' is assigned a value but never used.","'TOPcoinTotal' is assigned a value but never used.","'CoinMarketData' is defined but never used.","'cors' is defined but never used.","'upbitmarket' is defined but never used.","'newCoin' is assigned a value but never used.","no-sparse-arrays","Unexpected comma in middle of array.","ArrayExpression","unexpectedSparseArray","ReturnStatement","expectedReturnValue","Array.prototype.find() expects a value to be returned at the end of arrow function.","'stringdd' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]